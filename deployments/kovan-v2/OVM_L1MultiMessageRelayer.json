{
  "address": "0xf56d4FAeD6F52c4ce14e44885084dAFc5c440138",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_libAddressManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "target",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "sender",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "messageNonce",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "stateRoot",
                  "type": "bytes32"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "batchIndex",
                      "type": "uint256"
                    },
                    {
                      "internalType": "bytes32",
                      "name": "batchRoot",
                      "type": "bytes32"
                    },
                    {
                      "internalType": "uint256",
                      "name": "batchSize",
                      "type": "uint256"
                    },
                    {
                      "internalType": "uint256",
                      "name": "prevTotalElements",
                      "type": "uint256"
                    },
                    {
                      "internalType": "bytes",
                      "name": "extraData",
                      "type": "bytes"
                    }
                  ],
                  "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
                  "name": "stateRootBatchHeader",
                  "type": "tuple"
                },
                {
                  "components": [
                    {
                      "internalType": "uint256",
                      "name": "index",
                      "type": "uint256"
                    },
                    {
                      "internalType": "bytes32[]",
                      "name": "siblings",
                      "type": "bytes32[]"
                    }
                  ],
                  "internalType": "struct Lib_OVMCodec.ChainInclusionProof",
                  "name": "stateRootProof",
                  "type": "tuple"
                },
                {
                  "internalType": "bytes",
                  "name": "stateTrieWitness",
                  "type": "bytes"
                },
                {
                  "internalType": "bytes",
                  "name": "storageTrieWitness",
                  "type": "bytes"
                }
              ],
              "internalType": "struct iOVM_L1CrossDomainMessenger.L2MessageInclusionProof",
              "name": "proof",
              "type": "tuple"
            }
          ],
          "internalType": "struct iOVM_L1MultiMessageRelayer.L2ToL1Message[]",
          "name": "_messages",
          "type": "tuple[]"
        }
      ],
      "name": "batchRelayMessages",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "libAddressManager",
      "outputs": [
        {
          "internalType": "contract Lib_AddressManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x0e4af02ac2041ee5a1e4c30275da9a1daa76b9c7e1b07f3a82cf2073ba75fe5c",
  "receipt": {
    "to": null,
    "from": "0x18394B52d3Cb931dfA76F63251919D051953413d",
    "contractAddress": "0xf56d4FAeD6F52c4ce14e44885084dAFc5c440138",
    "transactionIndex": 4,
    "gasUsed": "596327",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc8cb94bc6a30dc6c6f9e0594d0f98f09383fd0be3e28cd670e7cee855adb6024",
    "transactionHash": "0x0e4af02ac2041ee5a1e4c30275da9a1daa76b9c7e1b07f3a82cf2073ba75fe5c",
    "logs": [],
    "blockNumber": 24199525,
    "cumulativeGasUsed": "942270",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xFaf27b24ba54C6910C12CFF5C9453C0e8D634e05"
  ],
  "solcInputHash": "03aed03b958b1d37f90bd88d0f56dd85",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"messageNonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"stateRootBatchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"stateRootProof\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"stateTrieWitness\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"storageTrieWitness\",\"type\":\"bytes\"}],\"internalType\":\"struct iOVM_L1CrossDomainMessenger.L2MessageInclusionProof\",\"name\":\"proof\",\"type\":\"tuple\"}],\"internalType\":\"struct iOVM_L1MultiMessageRelayer.L2ToL1Message[]\",\"name\":\"_messages\",\"type\":\"tuple[]\"}],\"name\":\"batchRelayMessages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The L1 Multi-Message Relayer contract is a gas efficiency optimization which enables the  relayer to submit multiple messages in a single transaction to be relayed by the L1 Cross Domain Message Sender. Compiler used: solc Runtime target: EVM\",\"kind\":\"dev\",\"methods\":{\"batchRelayMessages((address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))[])\":{\"params\":{\"_messages\":\"An array of L2 to L1 messages\"}}},\"title\":\"OVM_L1MultiMessageRelayer\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"batchRelayMessages((address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))[])\":{\"notice\":\"Forwards multiple cross domain messages to the L1 Cross Domain Messenger for relaying\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1MultiMessageRelayer.sol\":\"OVM_L1MultiMessageRelayer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1MultiMessageRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// @unsupported: ovm\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n/* Interface Imports */\\nimport { iOVM_L1CrossDomainMessenger } from \\\"../../../iOVM/bridge/messaging/iOVM_L1CrossDomainMessenger.sol\\\";\\nimport { iOVM_L1MultiMessageRelayer } from \\\"../../../iOVM/bridge/messaging/iOVM_L1MultiMessageRelayer.sol\\\";\\n\\n/* Contract Imports */\\nimport { Lib_AddressResolver } from \\\"../../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n\\n/**\\n * @title OVM_L1MultiMessageRelayer\\n * @dev The L1 Multi-Message Relayer contract is a gas efficiency optimization which enables the \\n * relayer to submit multiple messages in a single transaction to be relayed by the L1 Cross Domain\\n * Message Sender.\\n *\\n * Compiler used: solc\\n * Runtime target: EVM\\n */\\ncontract OVM_L1MultiMessageRelayer is iOVM_L1MultiMessageRelayer, Lib_AddressResolver {\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n    constructor(\\n        address _libAddressManager\\n    ) \\n        Lib_AddressResolver(_libAddressManager)\\n    {}\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    modifier onlyBatchRelayer() {\\n        require(\\n            msg.sender == resolve(\\\"OVM_L2BatchMessageRelayer\\\"),\\n            \\\"OVM_L1MultiMessageRelayer: Function can only be called by the OVM_L2BatchMessageRelayer\\\"\\n        );\\n        _;\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @notice Forwards multiple cross domain messages to the L1 Cross Domain Messenger for relaying\\n     * @param _messages An array of L2 to L1 messages\\n     */\\n    function batchRelayMessages(L2ToL1Message[] calldata _messages) \\n        override\\n        external\\n        onlyBatchRelayer \\n    {\\n        iOVM_L1CrossDomainMessenger messenger = iOVM_L1CrossDomainMessenger(resolve(\\\"Proxy__OVM_L1CrossDomainMessenger\\\"));\\n        for (uint256 i = 0; i < _messages.length; i++) {\\n            L2ToL1Message memory message = _messages[i];\\n            messenger.relayMessage(\\n                message.target,\\n                message.sender,\\n                message.message,\\n                message.messageNonce,\\n                message.proof\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbccd671aae35ef04fa45b3019f0a9d8d3e1d7b60a6261d979579f93f9c508725\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/bridge/messaging/iAbs_BaseCrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title iAbs_BaseCrossDomainMessenger\\n */\\ninterface iAbs_BaseCrossDomainMessenger {\\n\\n    /**********\\n     * Events *\\n     **********/\\n    event SentMessage(bytes message);\\n    event RelayedMessage(bytes32 msgHash);\\n\\n    /**********************\\n     * Contract Variables *\\n     **********************/\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\",\"keccak256\":\"0xc2bd6b373daae2ede34281f4be5938d02b9d1cfb056b40d65ff70b7f16ce3c86\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_L1CrossDomainMessenger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { iAbs_BaseCrossDomainMessenger } from \\\"./iAbs_BaseCrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title iOVM_L1CrossDomainMessenger\\n */\\ninterface iOVM_L1CrossDomainMessenger is iAbs_BaseCrossDomainMessenger {\\n\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    struct L2MessageInclusionProof {\\n        bytes32 stateRoot;\\n        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;\\n        Lib_OVMCodec.ChainInclusionProof stateRootProof;\\n        bytes stateTrieWitness;\\n        bytes storageTrieWitness;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @param _target Target contract address.\\n     * @param _sender Message sender address.\\n     * @param _message Message to send to the target.\\n     * @param _messageNonce Nonce for the provided message.\\n     * @param _proof Inclusion proof for the given message.\\n     */\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce,\\n        L2MessageInclusionProof memory _proof\\n    ) external;\\n\\n    /**\\n     * Replays a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _sender Original sender address.\\n     * @param _message Message to send to the target.\\n     * @param _messageNonce Nonce for the provided message.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function replayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\",\"keccak256\":\"0xdcd239d0b215e400674d78e8db4ac12ba18efc34fa78e24c2ff867f61062dba2\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_L1MultiMessageRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Interface Imports */\\nimport { iOVM_L1CrossDomainMessenger } from \\\"../../../iOVM/bridge/messaging/iOVM_L1CrossDomainMessenger.sol\\\";\\ninterface iOVM_L1MultiMessageRelayer {\\n\\n    struct L2ToL1Message {\\n        address target;\\n        address sender;\\n        bytes message;\\n        uint256 messageNonce;\\n        iOVM_L1CrossDomainMessenger.L2MessageInclusionProof proof;\\n    }\\n\\n    function batchRelayMessages(L2ToL1Message[] calldata _messages) external; \\n}\\n\",\"keccak256\":\"0xed86c23182a66b1a6c90c3f484b5d7264069e1a3849eb2fdd3608f9686282687\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/codec/Lib_OVMCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\nimport { Lib_SafeExecutionManagerWrapper } from \\\"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum EOASignatureType {\\n        EIP155_TRANSACTION,\\n        ETH_SIGNED_MESSAGE\\n    }\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Account {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n        address ethAddress;\\n        bool isFresh;\\n    }\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex;  // QUEUED TX ONLY\\n        uint256 timestamp;   // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData;        // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n    struct EIP155Transaction {\\n        uint256 nonce;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        uint256 chainId;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Decodes an EOA transaction (i.e., native Ethereum RLP encoding).\\n     * @param _transaction Encoded EOA transaction.\\n     * @return Transaction decoded into a struct.\\n     */\\n    function decodeEIP155Transaction(\\n        bytes memory _transaction,\\n        bool _isEthSignedMessage\\n    )\\n        internal\\n        pure\\n        returns (\\n            EIP155Transaction memory\\n        )\\n    {\\n        if (_isEthSignedMessage) {\\n            (\\n                uint256 _nonce,\\n                uint256 _gasLimit,\\n                uint256 _gasPrice,\\n                uint256 _chainId,\\n                address _to,\\n                bytes memory _data\\n            ) = abi.decode(\\n                _transaction,\\n                (uint256, uint256, uint256, uint256, address ,bytes)\\n            );\\n            return EIP155Transaction({\\n                nonce: _nonce,\\n                gasPrice: _gasPrice,\\n                gasLimit: _gasLimit,\\n                to: _to,\\n                value: 0,\\n                data: _data,\\n                chainId: _chainId\\n            });\\n        } else {\\n            Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_transaction);\\n\\n            return EIP155Transaction({\\n                nonce: Lib_RLPReader.readUint256(decoded[0]),\\n                gasPrice: Lib_RLPReader.readUint256(decoded[1]),\\n                gasLimit: Lib_RLPReader.readUint256(decoded[2]),\\n                to: Lib_RLPReader.readAddress(decoded[3]),\\n                value: Lib_RLPReader.readUint256(decoded[4]),\\n                data: Lib_RLPReader.readBytes(decoded[5]),\\n                chainId:  Lib_RLPReader.readUint256(decoded[6])\\n            });\\n        }\\n    }\\n\\n    /**\\n     * Decompresses a compressed EIP155 transaction.\\n     * @param _transaction Compressed EIP155 transaction bytes.\\n     * @return Transaction parsed into a struct.\\n     */\\n    function decompressEIP155Transaction(\\n        bytes memory _transaction\\n    )\\n        internal\\n        returns (\\n            EIP155Transaction memory\\n        )\\n    {\\n        return EIP155Transaction({\\n            gasLimit: Lib_BytesUtils.toUint24(_transaction, 0),\\n            gasPrice: uint256(Lib_BytesUtils.toUint24(_transaction, 3)) * 1000000,\\n            nonce: Lib_BytesUtils.toUint24(_transaction, 6),\\n            to: Lib_BytesUtils.toAddress(_transaction, 9),\\n            data: Lib_BytesUtils.slice(_transaction, 29),\\n            chainId: Lib_SafeExecutionManagerWrapper.safeCHAINID(),\\n            value: 0\\n        });\\n    }\\n\\n    /**\\n     * Encodes an EOA transaction back into the original transaction.\\n     * @param _transaction EIP155transaction to encode.\\n     * @param _isEthSignedMessage Whether or not this was an eth signed message.\\n     * @return Encoded transaction.\\n     */\\n    function encodeEIP155Transaction(\\n        EIP155Transaction memory _transaction,\\n        bool _isEthSignedMessage\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_isEthSignedMessage) {\\n            return abi.encode(\\n                _transaction.nonce,\\n                _transaction.gasLimit,\\n                _transaction.gasPrice,\\n                _transaction.chainId,\\n                _transaction.to,\\n                _transaction.data\\n            );\\n        } else {\\n            bytes[] memory raw = new bytes[](9);\\n\\n            raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\\n            raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\\n            raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\\n            if (_transaction.to == address(0)) {\\n                raw[3] = Lib_RLPWriter.writeBytes('');\\n            } else {\\n                raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\\n            }\\n            raw[4] = Lib_RLPWriter.writeUint(0);\\n            raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId);\\n            raw[7] = Lib_RLPWriter.writeBytes(bytes(''));\\n            raw[8] = Lib_RLPWriter.writeBytes(bytes(''));\\n\\n            return Lib_RLPWriter.writeList(raw);\\n        }\\n    }\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return abi.encodePacked(\\n            _transaction.timestamp,\\n            _transaction.blockNumber,\\n            _transaction.l1QueueOrigin,\\n            _transaction.l1TxOrigin,\\n            _transaction.entrypoint,\\n            _transaction.gasLimit,\\n            _transaction.data\\n        );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * Converts an OVM account to an EVM account.\\n     * @param _in OVM account to convert.\\n     * @return Converted EVM account.\\n     */\\n    function toEVMAccount(\\n        Account memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory\\n        )\\n    {\\n        return EVMAccount({\\n            nonce: _in.nonce,\\n            balance: _in.balance,\\n            storageRoot: _in.storageRoot,\\n            codeHash: _in.codeHash\\n        });\\n    }\\n\\n    /**\\n     * @notice RLP-encodes an account state struct.\\n     * @param _account Account state struct.\\n     * @return RLP-encoded account state.\\n     */\\n    function encodeEVMAccount(\\n        EVMAccount memory _account\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](4);\\n\\n        // Unfortunately we can't create this array outright because\\n        // Lib_RLPWriter.writeList will reject fixed-size arrays. Assigning\\n        // index-by-index circumvents this issue.\\n        raw[0] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.nonce)\\n            )\\n        );\\n        raw[1] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.balance)\\n            )\\n        );\\n        raw[2] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.storageRoot));\\n        raw[3] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.codeHash));\\n\\n        return Lib_RLPWriter.writeList(raw);\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(\\n        bytes memory _encoded\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return EVMAccount({\\n            nonce: Lib_RLPReader.readUint256(accountState[0]),\\n            balance: Lib_RLPReader.readUint256(accountState[1]),\\n            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n            codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n        });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(\\n            abi.encode(\\n                _batchHeader.batchRoot,\\n                _batchHeader.batchSize,\\n                _batchHeader.prevTotalElements,\\n                _batchHeader.extraData\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xe7e518ba7bba3fa28c532f8902576c1bb4dfc1ec4b62bed6da50623248ba17c3\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Contract Imports */\\nimport { Ownable } from \\\"./Lib_Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string _name,\\n        address _newAddress\\n    );\\n\\n    /*******************************************\\n     * Contract Variables: Internal Accounting *\\n     *******************************************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        public\\n        onlyOwner\\n    {\\n        emit AddressSet(_name, _address);\\n        addresses[_getNameHash(_name)] = _address;\\n    }\\n\\n    function getAddress(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0x3a490595cc21ff170e4027843093670ff845d5972481fbfb956b722ea564bb06\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n\\n    /*******************************************\\n     * Contract Variables: Contract References *\\n     *******************************************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    )  {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function resolve(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (\\n            address _contract\\n        )\\n    {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0xaa3ed342f6deb156c660fd83afa579a3b80db17eb465e8949cf5c1b114780143\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Ownable\\n * @dev Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n */\\nabstract contract Ownable {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    address public owner;\\n\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    modifier onlyOwner() {\\n        require(\\n            owner == msg.sender,\\n            \\\"Ownable: caller is not the owner\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function renounceOwnership()\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    function transferOwnership(address _newOwner)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        require(\\n            _newOwner != address(0),\\n            \\\"Ownable: new owner cannot be the zero address\\\"\\n        );\\n\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0xd9dfd9264e5b5fedd53a5b10fdf179c3f367614b0fe69179bce4e45119f5b739\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant internal MAX_LIST_LENGTH = 32;\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    \\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n    \\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n    \\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem memory\\n        )\\n    {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({\\n            length: _in.length,\\n            ptr: ptr\\n        });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        (\\n            uint256 listOffset,\\n            ,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"Invalid RLP list value.\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(\\n                itemCount < MAX_LIST_LENGTH,\\n                \\\"Provided RLP list exceeds max list length.\\\"\\n            );\\n\\n            (\\n                uint256 itemOffset,\\n                uint256 itemLength,\\n            ) = _decodeLength(RLPItem({\\n                length: _in.length - offset,\\n                ptr: _in.ptr + offset\\n            }));\\n\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: _in.ptr + offset\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        return readList(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes value.\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return readBytes(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return readString(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _in.length <= 33,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return readBytes32(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return readUint256(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _in.length == 1,\\n            \\\"Invalid RLP boolean value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(\\n            out == 0 || out == 1,\\n            \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\"\\n        );\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return readBool(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(\\n            _in.length == 21,\\n            \\\"Invalid RLP address value.\\\"\\n        );\\n\\n        return address(readUint256(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return readAddress(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(\\n            _in.length > 0,\\n            \\\"RLP item cannot be null.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n            \\n            require(\\n                _in.length > strLen,\\n                \\\"Invalid RLP short string.\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"Invalid RLP long string length.\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfStrLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"Invalid RLP long string.\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"Invalid RLP short list.\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"Invalid RLP long list length.\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfListLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"Invalid RLP long list.\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\\n        assembly {\\n            mstore(\\n                dest,\\n                or(\\n                    and(mload(src), not(mask)),\\n                    and(mload(dest), mask)\\n                )\\n            )\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0xbdb8fae0ca2483b4cc07607a5070fc25e33c54b4e4462b99e7c0b13aac48a09b\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return _out The RLP encoded list of items in bytes.\\n     */\\n    function writeList(\\n        bytes[] memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeString(\\n        string memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return _out The RLP encoded address in bytes.\\n     */\\n    function writeAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return _out The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(\\n        uint256 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return _out The RLP encoded bool in bytes.\\n     */\\n    function writeBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return _encoded RLP encoded bytes.\\n     */\\n    function _writeLength(\\n        uint256 _len,\\n        uint256 _offset\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return _binary RLP encoded bytes.\\n     */\\n    function _toBinary(\\n        uint256 _x\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _binary\\n        )\\n    {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    )\\n        private\\n        pure\\n    {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return _flattened The flattened byte string.\\n     */\\n    function _flatten(\\n        bytes[] memory _list\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _flattened\\n        )\\n    {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\",\"keccak256\":\"0xbcb24619c1758cb0d9f3fe5c79495950045a9087046a02b9ce01df46ae09ae5b\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(_in));\\n    }\\n\\n    /**\\n     * Removes the leading zeros from a bytes32 value and returns a new (smaller) bytes value.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 without any leading zeros.\\n     */\\n    function removeLeadingZeros(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out;\\n\\n        assembly {\\n            // Figure out how many leading zero bytes to remove.\\n            let shift := 0\\n            for { let i := 0 } and(lt(i, 32), eq(byte(i, _in), 0)) { i := add(i, 1) } {\\n                shift := add(shift, 1)\\n            }\\n\\n            // Reserve some space for our output and fix the free memory pointer.\\n            out := mload(0x40)\\n            mstore(0x40, add(out, 0x40))\\n\\n            // Shift the value and store it into the output bytes.\\n            mstore(add(out, 0x20), shl(mul(shift, 8), _in))\\n\\n            // Store the new size (with leading zero bytes removed) in the output byte size.\\n            mstore(out, sub(32, shift))\\n        }\\n\\n        return out;\\n    }\\n}\\n\",\"keccak256\":\"0xfa2def593e3fc56a31852c3744aefdaa93cec74e721bfcfeb1e5d166c7c60b64\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (_bytes.length - _start == 0) {\\n            return bytes('');\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32PadLeft(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 ret;\\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\\n        assembly {\\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\\n        }\\n        return ret;\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3 , \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(\\n        bytes memory _bytes,\\n        bytes memory _other\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0x0adf22e1b22ba09911e859f64cb3b484e992be4f9fd3b09088e6225bf8d06ce0\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_ErrorUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Lib_ErrorUtils\\n */\\nlibrary Lib_ErrorUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes an error string into raw solidity-style revert data.\\n     * (i.e. ascii bytes, prefixed with bytes4(keccak(\\\"Error(string))\\\"))\\n     * Ref: https://docs.soliditylang.org/en/v0.8.2/control-structures.html?highlight=Error(string)#panic-via-assert-and-error-via-require\\n     * @param _reason Reason for the reversion.\\n     * @return Standard solidity revert data for the given reason.\\n     */\\n    function encodeRevertString(\\n        string memory _reason\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return abi.encodeWithSignature(\\n            \\\"Error(string)\\\",\\n            _reason\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xfc64ec4a81fb50865b502a0004ed154e8598e1a313db77303fc95e41f536e6b7\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_ErrorUtils } from \\\"../utils/Lib_ErrorUtils.sol\\\";\\n\\n/**\\n * @title Lib_SafeExecutionManagerWrapper\\n * @dev The Safe Execution Manager Wrapper provides functions which facilitate writing OVM safe \\n * code using the standard solidity compiler, by routing all its operations through the Execution \\n * Manager.\\n * \\n * Compiler used: solc\\n * Runtime target: OVM\\n */\\nlibrary Lib_SafeExecutionManagerWrapper {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Performs a safe ovmCALL.\\n     * @param _gasLimit Gas limit for the call.\\n     * @param _target Address to call.\\n     * @param _calldata Data to send to the call.\\n     * @return _success Whether or not the call reverted.\\n     * @return _returndata Data returned by the call.\\n     */\\n    function safeCALL(\\n        uint256 _gasLimit,\\n        address _target,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCALL(uint256,address,bytes)\\\",\\n                _gasLimit,\\n                _target,\\n                _calldata\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bool, bytes));\\n    }\\n\\n    /**\\n     * Performs a safe ovmDELEGATECALL.\\n     * @param _gasLimit Gas limit for the call.\\n     * @param _target Address to call.\\n     * @param _calldata Data to send to the call.\\n     * @return _success Whether or not the call reverted.\\n     * @return _returndata Data returned by the call.\\n     */\\n    function safeDELEGATECALL(\\n        uint256 _gasLimit,\\n        address _target,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmDELEGATECALL(uint256,address,bytes)\\\",\\n                _gasLimit,\\n                _target,\\n                _calldata\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bool, bytes));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCREATE call.\\n     * @param _gasLimit Gas limit for the creation.\\n     * @param _bytecode Code for the new contract.\\n     * @return _contract Address of the created contract.\\n     */\\n    function safeCREATE(\\n        uint256 _gasLimit,\\n        bytes memory _bytecode\\n    )\\n        internal\\n        returns (\\n            address,\\n            bytes memory\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            _gasLimit,\\n            abi.encodeWithSignature(\\n                \\\"ovmCREATE(bytes)\\\",\\n                _bytecode\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address, bytes));\\n    }\\n\\n    /**\\n     * Performs a safe ovmEXTCODESIZE call.\\n     * @param _contract Address of the contract to query the size of.\\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\\n     */\\n    function safeEXTCODESIZE(\\n        address _contract\\n    )\\n        internal\\n        returns (\\n            uint256 _EXTCODESIZE\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmEXTCODESIZE(address)\\\",\\n                _contract\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCHAINID call.\\n     * @return _CHAINID Result of calling ovmCHAINID.\\n     */\\n    function safeCHAINID()\\n        internal\\n        returns (\\n            uint256 _CHAINID\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCHAINID()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCALLER call.\\n     * @return _CALLER Result of calling ovmCALLER.\\n     */\\n    function safeCALLER()\\n        internal\\n        returns (\\n            address _CALLER\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCALLER()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs a safe ovmADDRESS call.\\n     * @return _ADDRESS Result of calling ovmADDRESS.\\n     */\\n    function safeADDRESS()\\n        internal\\n        returns (\\n            address _ADDRESS\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmADDRESS()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs a safe ovmGETNONCE call.\\n     * @return _nonce Result of calling ovmGETNONCE.\\n     */\\n    function safeGETNONCE()\\n        internal\\n        returns (\\n            uint256 _nonce\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmGETNONCE()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmINCREMENTNONCE call.\\n     */\\n    function safeINCREMENTNONCE()\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmINCREMENTNONCE()\\\"\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe ovmCREATEEOA call.\\n     * @param _messageHash Message hash which was signed by EOA\\n     * @param _v v value of signature (0 or 1)\\n     * @param _r r value of signature\\n     * @param _s s value of signature\\n     */\\n    function safeCREATEEOA(\\n        bytes32 _messageHash,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\\\",\\n                _messageHash,\\n                _v,\\n                _r,\\n                _s\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe REVERT.\\n     * @param _reason String revert reason to pass along with the REVERT.\\n     */\\n    function safeREVERT(\\n        string memory _reason\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmREVERT(bytes)\\\",\\n                Lib_ErrorUtils.encodeRevertString(\\n                    _reason\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe \\\"require\\\".\\n     * @param _condition Boolean condition that must be true or will revert.\\n     * @param _reason String revert reason to pass along with the REVERT.\\n     */\\n    function safeREQUIRE(\\n        bool _condition,\\n        string memory _reason\\n    )\\n        internal\\n    {\\n        if (!_condition) {\\n            safeREVERT(\\n                _reason\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Performs a safe ovmSLOAD call.\\n     */\\n    function safeSLOAD(\\n        bytes32 _key\\n    )\\n        internal\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSLOAD(bytes32)\\\",\\n                _key\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bytes32));\\n    }\\n\\n    /**\\n     * Performs a safe ovmSSTORE call.\\n     */\\n    function safeSSTORE(\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSSTORE(bytes32,bytes32)\\\",\\n                _key,\\n                _value\\n            )\\n        );\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Performs an ovm interaction and the necessary safety checks.\\n     * @param _gasLimit Gas limit for the interaction.\\n     * @param _calldata Data to send to the OVM_ExecutionManager (encoded with sighash).\\n     * @return _returndata Data sent back by the OVM_ExecutionManager.\\n     */\\n    function _safeExecutionManagerInteraction(\\n        uint256 _gasLimit,\\n        bytes memory _calldata\\n    )\\n        private\\n        returns (\\n            bytes memory _returndata\\n        )\\n    {\\n        address ovmExecutionManager = msg.sender;\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = ovmExecutionManager.call{gas: _gasLimit}(_calldata);\\n\\n        if (success == false) {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else if (returndata.length == 1) {\\n            assembly {\\n                return(0, 1)\\n            }\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    function _safeExecutionManagerInteraction(\\n        bytes memory _calldata\\n    )\\n        private\\n        returns (\\n            bytes memory _returndata\\n        )\\n    {\\n        return _safeExecutionManagerInteraction(\\n            gasleft(),\\n            _calldata\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x41e146e7912af794a17cd43c5a276674be956bfa8f3ca5b451bcb82d81e6f492\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506040516109f93803806109f983398101604081905261002f91610054565b600080546001600160a01b0319166001600160a01b0392909216919091179055610082565b600060208284031215610065578081fd5b81516001600160a01b038116811461007b578182fd5b9392505050565b610968806100916000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806316e9cd9b14610046578063299ca4781461005b578063461a447814610079575b600080fd5b61005961005436600461057d565b61008c565b005b6100636101ea565b60405161007091906106db565b60405180910390f35b6100636100873660046105ec565b6101f9565b6100ca6040518060400160405280601981526020017f4f564d5f4c3242617463684d65737361676552656c61796572000000000000008152506101f9565b6001600160a01b0316336001600160a01b0316146101035760405162461bcd60e51b81526004016100fa906107d7565b60405180910390fd5b600061012660405180606001604052806021815260200161093b602191396101f9565b905060005b828110156101e457600084848381811061014157fe5b9050602002810190610153919061085a565b61015c9061089d565b8051602082015160408084015160608501516080860151925163d7fd19dd60e01b81529596506001600160a01b0389169563d7fd19dd956101a5959094909392916004016106ef565b600060405180830381600087803b1580156101bf57600080fd5b505af11580156101d3573d6000803e3d6000fd5b50506001909301925061012b915050565b50505050565b6000546001600160a01b031681565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b83811015610259578181015183820152602001610241565b50505050905090810190601f1680156102865780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156102a357600080fd5b505afa1580156102b7573d6000803e3d6000fd5b505050506040513d60208110156102cd57600080fd5b505190505b919050565b600067ffffffffffffffff8311156102eb57fe5b6102fe601f8401601f1916602001610879565b905082815283838301111561031257600080fd5b828260208301376000602084830101529392505050565b80356001600160a01b03811681146102d257600080fd5b600082601f830112610350578081fd5b61035f838335602085016102d7565b9392505050565b600060a08284031215610377578081fd5b60405160a0810167ffffffffffffffff828210818311171561039557fe5b816040528293508435835260208501356020840152604085013560408401526060850135606084015260808501359150808211156103d257600080fd5b506103df85828601610340565b6080830152505092915050565b6000604082840312156103fd578081fd5b6040516040810167ffffffffffffffff828210818311171561041b57fe5b816040528293508435835260209150818501358181111561043b57600080fd5b8501601f8101871361044c57600080fd5b80358281111561045857fe5b8381029250610468848401610879565b8181528481019083860185850187018b101561048357600080fd5b600095505b838610156104a6578035835260019590950194918601918601610488565b5080868801525050505050505092915050565b600060a082840312156104ca578081fd5b6104d460a0610879565b905081358152602082013567ffffffffffffffff808211156104f557600080fd5b61050185838601610366565b6020840152604084013591508082111561051a57600080fd5b610526858386016103ec565b6040840152606084013591508082111561053f57600080fd5b61054b85838601610340565b6060840152608084013591508082111561056457600080fd5b5061057184828501610340565b60808301525092915050565b6000806020838503121561058f578182fd5b823567ffffffffffffffff808211156105a6578384fd5b818501915085601f8301126105b9578384fd5b8135818111156105c7578485fd5b86602080830285010111156105da578485fd5b60209290920196919550909350505050565b6000602082840312156105fd578081fd5b813567ffffffffffffffff811115610613578182fd5b8201601f81018413610623578182fd5b610632848235602084016102d7565b949350505050565b60008151808452815b8181101561065f57602081850181015186830182015201610643565b818111156106705782602083870101525b50601f01601f19169290920160200192915050565b6000604083018251845260208084015160408287015282815180855260608801915083830194508592505b808310156106d057845182529383019360019290920191908301906106b0565b509695505050505050565b6001600160a01b0391909116815260200190565b6001600160a01b0386811682528516602082015260a06040820181905260009061071b9083018661063a565b846060840152828103608084015283518152602084015160a06020830152805160a0830152602081015160c0830152604081015160e083015260608101516101008301526080810151905060a061012083015261077c61014083018261063a565b9050604085015182820360408401526107958282610685565b915050606085015182820360608401526107af828261063a565b915050608085015182820360808401526107c9828261063a565b9a9950505050505050505050565b60208082526057908201527f4f564d5f4c314d756c74694d65737361676552656c617965723a2046756e637460408201527f696f6e2063616e206f6e6c792062652063616c6c656420627920746865204f5660608201527f4d5f4c3242617463684d65737361676552656c61796572000000000000000000608082015260a00190565b60008235609e1983360301811261086f578182fd5b9190910192915050565b60405181810167ffffffffffffffff8111828210171561089557fe5b604052919050565b600060a082360312156108ae578081fd5b60405160a0810167ffffffffffffffff82821081831117156108cc57fe5b816040526108d985610329565b83526108e760208601610329565b602084015260408501359150808211156108ff578384fd5b61090b36838701610340565b604084015260608501356060840152608085013591508082111561092d578384fd5b50610571368286016104b956fe50726f78795f5f4f564d5f4c3143726f7373446f6d61696e4d657373656e676572a164736f6c6343000706000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806316e9cd9b14610046578063299ca4781461005b578063461a447814610079575b600080fd5b61005961005436600461057d565b61008c565b005b6100636101ea565b60405161007091906106db565b60405180910390f35b6100636100873660046105ec565b6101f9565b6100ca6040518060400160405280601981526020017f4f564d5f4c3242617463684d65737361676552656c61796572000000000000008152506101f9565b6001600160a01b0316336001600160a01b0316146101035760405162461bcd60e51b81526004016100fa906107d7565b60405180910390fd5b600061012660405180606001604052806021815260200161093b602191396101f9565b905060005b828110156101e457600084848381811061014157fe5b9050602002810190610153919061085a565b61015c9061089d565b8051602082015160408084015160608501516080860151925163d7fd19dd60e01b81529596506001600160a01b0389169563d7fd19dd956101a5959094909392916004016106ef565b600060405180830381600087803b1580156101bf57600080fd5b505af11580156101d3573d6000803e3d6000fd5b50506001909301925061012b915050565b50505050565b6000546001600160a01b031681565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b83811015610259578181015183820152602001610241565b50505050905090810190601f1680156102865780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b1580156102a357600080fd5b505afa1580156102b7573d6000803e3d6000fd5b505050506040513d60208110156102cd57600080fd5b505190505b919050565b600067ffffffffffffffff8311156102eb57fe5b6102fe601f8401601f1916602001610879565b905082815283838301111561031257600080fd5b828260208301376000602084830101529392505050565b80356001600160a01b03811681146102d257600080fd5b600082601f830112610350578081fd5b61035f838335602085016102d7565b9392505050565b600060a08284031215610377578081fd5b60405160a0810167ffffffffffffffff828210818311171561039557fe5b816040528293508435835260208501356020840152604085013560408401526060850135606084015260808501359150808211156103d257600080fd5b506103df85828601610340565b6080830152505092915050565b6000604082840312156103fd578081fd5b6040516040810167ffffffffffffffff828210818311171561041b57fe5b816040528293508435835260209150818501358181111561043b57600080fd5b8501601f8101871361044c57600080fd5b80358281111561045857fe5b8381029250610468848401610879565b8181528481019083860185850187018b101561048357600080fd5b600095505b838610156104a6578035835260019590950194918601918601610488565b5080868801525050505050505092915050565b600060a082840312156104ca578081fd5b6104d460a0610879565b905081358152602082013567ffffffffffffffff808211156104f557600080fd5b61050185838601610366565b6020840152604084013591508082111561051a57600080fd5b610526858386016103ec565b6040840152606084013591508082111561053f57600080fd5b61054b85838601610340565b6060840152608084013591508082111561056457600080fd5b5061057184828501610340565b60808301525092915050565b6000806020838503121561058f578182fd5b823567ffffffffffffffff808211156105a6578384fd5b818501915085601f8301126105b9578384fd5b8135818111156105c7578485fd5b86602080830285010111156105da578485fd5b60209290920196919550909350505050565b6000602082840312156105fd578081fd5b813567ffffffffffffffff811115610613578182fd5b8201601f81018413610623578182fd5b610632848235602084016102d7565b949350505050565b60008151808452815b8181101561065f57602081850181015186830182015201610643565b818111156106705782602083870101525b50601f01601f19169290920160200192915050565b6000604083018251845260208084015160408287015282815180855260608801915083830194508592505b808310156106d057845182529383019360019290920191908301906106b0565b509695505050505050565b6001600160a01b0391909116815260200190565b6001600160a01b0386811682528516602082015260a06040820181905260009061071b9083018661063a565b846060840152828103608084015283518152602084015160a06020830152805160a0830152602081015160c0830152604081015160e083015260608101516101008301526080810151905060a061012083015261077c61014083018261063a565b9050604085015182820360408401526107958282610685565b915050606085015182820360608401526107af828261063a565b915050608085015182820360808401526107c9828261063a565b9a9950505050505050505050565b60208082526057908201527f4f564d5f4c314d756c74694d65737361676552656c617965723a2046756e637460408201527f696f6e2063616e206f6e6c792062652063616c6c656420627920746865204f5660608201527f4d5f4c3242617463684d65737361676552656c61796572000000000000000000608082015260a00190565b60008235609e1983360301811261086f578182fd5b9190910192915050565b60405181810167ffffffffffffffff8111828210171561089557fe5b604052919050565b600060a082360312156108ae578081fd5b60405160a0810167ffffffffffffffff82821081831117156108cc57fe5b816040526108d985610329565b83526108e760208601610329565b602084015260408501359150808211156108ff578384fd5b61090b36838701610340565b604084015260608501356060840152608085013591508082111561092d578384fd5b50610571368286016104b956fe50726f78795f5f4f564d5f4c3143726f7373446f6d61696e4d657373656e676572a164736f6c6343000706000a",
  "devdoc": {
    "details": "The L1 Multi-Message Relayer contract is a gas efficiency optimization which enables the  relayer to submit multiple messages in a single transaction to be relayed by the L1 Cross Domain Message Sender. Compiler used: solc Runtime target: EVM",
    "kind": "dev",
    "methods": {
      "batchRelayMessages((address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))[])": {
        "params": {
          "_messages": "An array of L2 to L1 messages"
        }
      }
    },
    "title": "OVM_L1MultiMessageRelayer",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "batchRelayMessages((address,address,bytes,uint256,(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes,bytes))[])": {
        "notice": "Forwards multiple cross domain messages to the L1 Cross Domain Messenger for relaying"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 12526,
        "contract": "contracts/optimistic-ethereum/OVM/bridge/messaging/OVM_L1MultiMessageRelayer.sol:OVM_L1MultiMessageRelayer",
        "label": "libAddressManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Lib_AddressManager)12519"
      }
    ],
    "types": {
      "t_contract(Lib_AddressManager)12519": {
        "encoding": "inplace",
        "label": "contract Lib_AddressManager",
        "numberOfBytes": "20"
      }
    }
  }
}