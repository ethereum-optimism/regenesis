{
  "address": "0x5A3D7759d2126e9909c768e91D51CFB3D1Fb78C8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_libAddressManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_preStateRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_preStateRootIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_transactionHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_who",
          "type": "address"
        }
      ],
      "name": "FraudProofFinalized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_preStateRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_preStateRootIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_transactionHash",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_who",
          "type": "address"
        }
      ],
      "name": "FraudProofInitialized",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_preStateRoot",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
          "name": "_preStateRootBatchHeader",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "siblings",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainInclusionProof",
          "name": "_preStateRootProof",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "_txHash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_postStateRoot",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
          "name": "_postStateRootBatchHeader",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "siblings",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainInclusionProof",
          "name": "_postStateRootProof",
          "type": "tuple"
        }
      ],
      "name": "finalizeFraudVerification",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_preStateRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_txHash",
          "type": "bytes32"
        }
      ],
      "name": "getStateTransitioner",
      "outputs": [
        {
          "internalType": "contract iOVM_StateTransitioner",
          "name": "_transitioner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_preStateRoot",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
          "name": "_preStateRootBatchHeader",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "siblings",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainInclusionProof",
          "name": "_preStateRootProof",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "enum Lib_OVMCodec.QueueOrigin",
              "name": "l1QueueOrigin",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "l1TxOrigin",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "entrypoint",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "gasLimit",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.Transaction",
          "name": "_transaction",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isSequenced",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "queueIndex",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "txData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.TransactionChainElement",
          "name": "_txChainElement",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
          "name": "_transactionBatchHeader",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "siblings",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainInclusionProof",
          "name": "_transactionProof",
          "type": "tuple"
        }
      ],
      "name": "initializeFraudVerification",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "address",
          "name": "_contract",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x336291c20891e0cc5dc07036b35b8f0330b77552947f3c804ec700fde71031e1",
  "receipt": {
    "to": null,
    "from": "0x558ba9b8d78713fbf768c1f8a584485B4003f43F",
    "contractAddress": "0x5A3D7759d2126e9909c768e91D51CFB3D1Fb78C8",
    "transactionIndex": 7,
    "gasUsed": "1376911",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2efe0d2b3bb653e73376e4d5fe59b312a4006cf9ad0144381763472ba67b0b81",
    "transactionHash": "0x336291c20891e0cc5dc07036b35b8f0330b77552947f3c804ec700fde71031e1",
    "logs": [],
    "blockNumber": 4529210,
    "cumulativeGasUsed": "2304956",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5011A092e66B2c89e2d09dfb9E418B4bCFb24C80"
  ],
  "solcInputHash": "cebcb515c1a9c570d96e0b8f6fd237e2",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_preStateRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_preStateRootIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"FraudProofFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_preStateRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_preStateRootIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_transactionHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"FraudProofInitialized\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_preStateRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"_preStateRootBatchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"_preStateRootProof\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_txHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_postStateRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"_postStateRootBatchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"_postStateRootProof\",\"type\":\"tuple\"}],\"name\":\"finalizeFraudVerification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_preStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_txHash\",\"type\":\"bytes32\"}],\"name\":\"getStateTransitioner\",\"outputs\":[{\"internalType\":\"contract iOVM_StateTransitioner\",\"name\":\"_transitioner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_preStateRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"_preStateRootBatchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"_preStateRootProof\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"enum Lib_OVMCodec.QueueOrigin\",\"name\":\"l1QueueOrigin\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"l1TxOrigin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"entrypoint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.Transaction\",\"name\":\"_transaction\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isSequenced\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"queueIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.TransactionChainElement\",\"name\":\"_txChainElement\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"_transactionBatchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"_transactionProof\",\"type\":\"tuple\"}],\"name\":\"initializeFraudVerification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_libAddressManager\":\"Address of the Address Manager.\"}},\"finalizeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes32,bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))\":{\"params\":{\"_postStateRoot\":\"State root after the fraudulent transaction.\",\"_postStateRootBatchHeader\":\"Batch header for the provided post-state root.\",\"_postStateRootProof\":\"Inclusion proof for the provided post-state root.\",\"_preStateRoot\":\"State root before the fraudulent transaction.\",\"_preStateRootBatchHeader\":\"Batch header for the provided pre-state root.\",\"_preStateRootProof\":\"Inclusion proof for the provided pre-state root.\",\"_txHash\":\"The transaction for the state root\"}},\"getStateTransitioner(bytes32,bytes32)\":{\"params\":{\"_preStateRoot\":\"State root to query a transitioner for.\"},\"returns\":{\"_transitioner\":\"Corresponding state transitioner contract.\"}},\"initializeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),(uint256,uint256,uint8,address,address,uint256,bytes),(bool,uint256,uint256,uint256,bytes),(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))\":{\"params\":{\"_preStateRoot\":\"State root before the fraudulent transaction.\",\"_preStateRootBatchHeader\":\"Batch header for the provided pre-state root.\",\"_preStateRootProof\":\"Inclusion proof for the provided pre-state root.\",\"_transaction\":\"OVM transaction claimed to be fraudulent.\",\"_transactionBatchHeader\":\"Batch header for the provided transaction.\",\"_transactionProof\":\"Inclusion proof for the provided transaction.\",\"_txChainElement\":\"OVM transaction chain element.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"finalizeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes32,bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))\":{\"notice\":\"Finalizes the fraud verification process.\"},\"getStateTransitioner(bytes32,bytes32)\":{\"notice\":\"Retrieves the state transitioner for a given root.\"},\"initializeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),(uint256,uint256,uint8,address,address,uint256,bytes),(bool,uint256,uint256,uint256,bytes),(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))\":{\"notice\":\"Begins the fraud verification process.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol\":\"OVM_FraudVerifier\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/optimistic-ethereum/OVM/verification/OVM_FraudContributor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport { iOVM_BondManager } from \\\"../../iOVM/verification/iOVM_BondManager.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/// Minimal contract to be inherited by contracts consumed by users that provide\\n/// data for fraud proofs\\nabstract contract OVM_FraudContributor is Lib_AddressResolver {\\n    /// Decorate your functions with this modifier to store how much total gas was\\n    /// consumed by the sender, to reward users fairly\\n    modifier contributesToFraudProof(bytes32 preStateRoot, bytes32 txHash) {\\n        uint256 startGas = gasleft();\\n        _;\\n        uint256 gasSpent = startGas - gasleft();\\n        iOVM_BondManager(resolve('OVM_BondManager')).recordGasSpent(preStateRoot, txHash, msg.sender, gasSpent);\\n    }\\n}\\n\",\"keccak256\":\"0xcfe2988b5509793a281b18fa0b33bb15aab4ab3205a24c12c11d33424e00ebc9\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_FraudVerifier } from \\\"../../iOVM/verification/iOVM_FraudVerifier.sol\\\";\\nimport { iOVM_StateTransitioner } from \\\"../../iOVM/verification/iOVM_StateTransitioner.sol\\\";\\nimport { iOVM_StateTransitionerFactory } from \\\"../../iOVM/verification/iOVM_StateTransitionerFactory.sol\\\";\\nimport { iOVM_BondManager } from \\\"../../iOVM/verification/iOVM_BondManager.sol\\\";\\nimport { iOVM_StateCommitmentChain } from \\\"../../iOVM/chain/iOVM_StateCommitmentChain.sol\\\";\\nimport { iOVM_CanonicalTransactionChain } from \\\"../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\\\";\\n\\n/* Contract Imports */\\nimport { OVM_FraudContributor } from \\\"./OVM_FraudContributor.sol\\\";\\n\\ncontract OVM_FraudVerifier is Lib_AddressResolver, OVM_FraudContributor, iOVM_FraudVerifier {\\n\\n    /*******************************************\\n     * Contract Variables: Internal Accounting *\\n     *******************************************/\\n\\n    mapping (bytes32 => iOVM_StateTransitioner) internal transitioners;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    )\\n        Lib_AddressResolver(_libAddressManager)\\n    {}\\n\\n\\n    /***************************************\\n     * Public Functions: Transition Status *\\n     ***************************************/\\n\\n    /**\\n     * Retrieves the state transitioner for a given root.\\n     * @param _preStateRoot State root to query a transitioner for.\\n     * @return _transitioner Corresponding state transitioner contract.\\n     */\\n    function getStateTransitioner(\\n        bytes32 _preStateRoot,\\n        bytes32 _txHash\\n    )\\n        override\\n        public\\n        view\\n        returns (\\n            iOVM_StateTransitioner _transitioner\\n        )\\n    {\\n        return transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))];\\n    }\\n\\n\\n    /****************************************\\n     * Public Functions: Fraud Verification *\\n     ****************************************/\\n\\n    /**\\n     * Begins the fraud verification process.\\n     * @param _preStateRoot State root before the fraudulent transaction.\\n     * @param _preStateRootBatchHeader Batch header for the provided pre-state root.\\n     * @param _preStateRootProof Inclusion proof for the provided pre-state root.\\n     * @param _transaction OVM transaction claimed to be fraudulent.\\n     * @param _txChainElement OVM transaction chain element.\\n     * @param _transactionBatchHeader Batch header for the provided transaction.\\n     * @param _transactionProof Inclusion proof for the provided transaction.\\n     */\\n    function initializeFraudVerification(\\n        bytes32 _preStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\\n        Lib_OVMCodec.Transaction memory _transaction,\\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\\n        Lib_OVMCodec.ChainBatchHeader memory _transactionBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _transactionProof\\n    )\\n        override\\n        public\\n        contributesToFraudProof(_preStateRoot, Lib_OVMCodec.hashTransaction(_transaction))\\n    {\\n        bytes32 _txHash = Lib_OVMCodec.hashTransaction(_transaction);\\n\\n        if (_hasStateTransitioner(_preStateRoot, _txHash)) {\\n            return;\\n        }\\n\\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\\\"OVM_StateCommitmentChain\\\"));\\n        iOVM_CanonicalTransactionChain ovmCanonicalTransactionChain = iOVM_CanonicalTransactionChain(resolve(\\\"OVM_CanonicalTransactionChain\\\"));\\n\\n        require(\\n            ovmStateCommitmentChain.verifyStateCommitment(\\n                _preStateRoot,\\n                _preStateRootBatchHeader,\\n                _preStateRootProof\\n            ),\\n            \\\"Invalid pre-state root inclusion proof.\\\"\\n        );\\n\\n        require(\\n            ovmCanonicalTransactionChain.verifyTransaction(\\n                _transaction,\\n                _txChainElement,\\n                _transactionBatchHeader,\\n                _transactionProof\\n            ),\\n            \\\"Invalid transaction inclusion proof.\\\"\\n        );\\n\\n        require (\\n            _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1 == _transactionBatchHeader.prevTotalElements + _transactionProof.index,\\n            \\\"Pre-state root global index must equal to the transaction root global index.\\\"\\n        );\\n\\n        _deployTransitioner(_preStateRoot, _txHash, _preStateRootProof.index);\\n\\n        emit FraudProofInitialized(\\n            _preStateRoot,\\n            _preStateRootProof.index,\\n            _txHash,\\n            msg.sender\\n        );\\n    }\\n\\n    /**\\n     * Finalizes the fraud verification process.\\n     * @param _preStateRoot State root before the fraudulent transaction.\\n     * @param _preStateRootBatchHeader Batch header for the provided pre-state root.\\n     * @param _preStateRootProof Inclusion proof for the provided pre-state root.\\n     * @param _txHash The transaction for the state root\\n     * @param _postStateRoot State root after the fraudulent transaction.\\n     * @param _postStateRootBatchHeader Batch header for the provided post-state root.\\n     * @param _postStateRootProof Inclusion proof for the provided post-state root.\\n     */\\n    function finalizeFraudVerification(\\n        bytes32 _preStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\\n        bytes32 _txHash,\\n        bytes32 _postStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _postStateRootProof\\n    )\\n        override\\n        public\\n        contributesToFraudProof(_preStateRoot, _txHash)\\n    {\\n        iOVM_StateTransitioner transitioner = getStateTransitioner(_preStateRoot, _txHash);\\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\\\"OVM_StateCommitmentChain\\\"));\\n        iOVM_BondManager ovmBondManager = iOVM_BondManager(resolve(\\\"OVM_BondManager\\\"));\\n\\n        require(\\n            transitioner.isComplete() == true,\\n            \\\"State transition process must be completed prior to finalization.\\\"\\n        );\\n\\n        require (\\n            _postStateRootBatchHeader.prevTotalElements + _postStateRootProof.index == _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1,\\n            \\\"Post-state root global index must equal to the pre state root global index plus one.\\\"\\n        );\\n\\n        require(\\n            ovmStateCommitmentChain.verifyStateCommitment(\\n                _preStateRoot,\\n                _preStateRootBatchHeader,\\n                _preStateRootProof\\n            ),\\n            \\\"Invalid pre-state root inclusion proof.\\\"\\n        );\\n\\n        require(\\n            ovmStateCommitmentChain.verifyStateCommitment(\\n                _postStateRoot,\\n                _postStateRootBatchHeader,\\n                _postStateRootProof\\n            ),\\n            \\\"Invalid post-state root inclusion proof.\\\"\\n        );\\n\\n        // If the post state root did not match, then there was fraud and we should delete the batch\\n        require(\\n            _postStateRoot != transitioner.getPostStateRoot(),\\n            \\\"State transition has not been proven fraudulent.\\\"\\n        );\\n        \\n        _cancelStateTransition(_postStateRootBatchHeader, _preStateRoot);\\n\\n        // TEMPORARY: Remove the transitioner; for minnet.\\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitioner(0x0000000000000000000000000000000000000000);\\n\\n        emit FraudProofFinalized(\\n            _preStateRoot,\\n            _preStateRootProof.index,\\n            _txHash,\\n            msg.sender\\n        );\\n    }\\n\\n\\n    /************************************\\n     * Internal Functions: Verification *\\n     ************************************/\\n\\n    /**\\n     * Checks whether a transitioner already exists for a given pre-state root.\\n     * @param _preStateRoot Pre-state root to check.\\n     * @return _exists Whether or not we already have a transitioner for the root.\\n     */\\n    function _hasStateTransitioner(\\n        bytes32 _preStateRoot,\\n        bytes32 _txHash\\n    )\\n        internal\\n        view\\n        returns (\\n            bool _exists\\n        )\\n    {\\n        return address(getStateTransitioner(_preStateRoot, _txHash)) != address(0);\\n    }\\n\\n    /**\\n     * Deploys a new state transitioner.\\n     * @param _preStateRoot Pre-state root to initialize the transitioner with.\\n     * @param _txHash Hash of the transaction this transitioner will execute.\\n     * @param _stateTransitionIndex Index of the transaction in the chain.\\n     */\\n    function _deployTransitioner(\\n        bytes32 _preStateRoot,\\n        bytes32 _txHash,\\n        uint256 _stateTransitionIndex\\n    )\\n        internal\\n    {\\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitionerFactory(\\n            resolve(\\\"OVM_StateTransitionerFactory\\\")\\n        ).create(\\n            address(libAddressManager),\\n            _stateTransitionIndex,\\n            _preStateRoot,\\n            _txHash\\n        );\\n    }\\n\\n    /**\\n     * Removes a state transition from the state commitment chain.\\n     * @param _postStateRootBatchHeader Header for the post-state root.\\n     * @param _preStateRoot Pre-state root hash.\\n     */\\n    function _cancelStateTransition(\\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\\n        bytes32 _preStateRoot\\n    )\\n        internal\\n    {\\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\\\"OVM_StateCommitmentChain\\\"));\\n        iOVM_BondManager ovmBondManager = iOVM_BondManager(resolve(\\\"OVM_BondManager\\\"));\\n\\n        // Delete the state batch.\\n        ovmStateCommitmentChain.deleteStateBatch(\\n            _postStateRootBatchHeader\\n        );\\n\\n        // Get the timestamp and publisher for that block.\\n        (uint256 timestamp, address publisher) = abi.decode(_postStateRootBatchHeader.extraData, (uint256, address));\\n\\n        // Slash the bonds at the bond manager.\\n        ovmBondManager.finalize(\\n            _preStateRoot,\\n            publisher,\\n            timestamp\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x005d38d7ca767a61c3583a46d7087c74210334e86397681e52308c5cfd7f840c\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/chain/iOVM_CanonicalTransactionChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title iOVM_CanonicalTransactionChain\\n */\\ninterface iOVM_CanonicalTransactionChain {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event TransactionEnqueued(\\n        address _l1TxOrigin,\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes _data,\\n        uint256 _queueIndex,\\n        uint256 _timestamp\\n    );\\n\\n    event QueueBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event SequencerBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event TransactionBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct BatchContext {\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements()\\n        external\\n        view\\n        returns (\\n            uint256 _totalElements\\n        );\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches()\\n        external\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        );\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Length of the queue.\\n     */\\n    function getNumPendingQueueElements()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueElement memory _element\\n        );\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        external;\\n\\n    /**\\n     * Appends a given number of queued transactions as a single batch.\\n     * @param _numQueuedTransactions Number of transactions to append.\\n     */\\n    function appendQueueBatch(\\n        uint256 _numQueuedTransactions\\n    )\\n        external;\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch(\\n        // uint40 _shouldStartAtElement,\\n        // uint24 _totalElementsToAppend,\\n        // BatchContext[] _contexts,\\n        // bytes[] _transactionDataFields\\n    )\\n        external;\\n\\n    /**\\n     * Verifies whether a transaction is included in the chain.\\n     * @param _transaction Transaction to verify.\\n     * @param _txChainElement Transaction chain element corresponding to the transaction.\\n     * @param _batchHeader Header of the batch the transaction was included in.\\n     * @param _inclusionProof Inclusion proof for the provided transaction chain element.\\n     * @return True if the transaction exists in the CTC, false if not.\\n     */\\n    function verifyTransaction(\\n        Lib_OVMCodec.Transaction memory _transaction,\\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\\n    )\\n        external\\n        view\\n        returns (\\n            bool\\n        );\\n}\\n\",\"keccak256\":\"0x82a4e62286c8bc5e2d3de33f66d9b707cb9636e553dca54b5e95277bd794a934\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/chain/iOVM_StateCommitmentChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title iOVM_StateCommitmentChain\\n */\\ninterface iOVM_StateCommitmentChain {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event StateBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n    event StateBatchDeleted(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot\\n    );\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements()\\n        external\\n        view\\n        returns (\\n            uint256 _totalElements\\n        );\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches()\\n        external\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        );\\n\\n    /**\\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\\n     */\\n    function getLastSequencerTimestamp()\\n        external\\n        view\\n        returns (\\n            uint256 _lastSequencerTimestamp\\n        );\\n\\n    /**\\n     * Appends a batch of state roots to the chain.\\n     * @param _batch Batch of state roots.\\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\\n     */\\n    function appendStateBatch(\\n        bytes32[] calldata _batch,\\n        uint256 _shouldStartAtElement\\n    )\\n        external;\\n\\n    /**\\n     * Deletes all state roots after (and including) a given batch.\\n     * @param _batchHeader Header of the batch to start deleting from.\\n     */\\n    function deleteStateBatch(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        external;\\n\\n    /**\\n     * Verifies a batch inclusion proof.\\n     * @param _element Hash of the element to verify a proof for.\\n     * @param _batchHeader Header of the batch in which the element was included.\\n     * @param _proof Merkle inclusion proof for the element.\\n     */\\n    function verifyStateCommitment(\\n        bytes32 _element,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _proof\\n    )\\n        external\\n        view\\n        returns (\\n            bool _verified\\n        );\\n\\n    /**\\n     * Checks whether a given batch is still inside its fraud proof window.\\n     * @param _batchHeader Header of the batch to check.\\n     * @return _inside Whether or not the batch is inside the fraud proof window.\\n     */\\n    function insideFraudProofWindow(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        external\\n        view\\n        returns (\\n            bool _inside\\n        );\\n}\\n\",\"keccak256\":\"0x6646d6ff392b81aab52a7a277e91540819464751de0af5afd1962094b2e92448\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/verification/iOVM_BondManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\ninterface ERC20 {\\n    function transfer(address, uint256) external returns (bool);\\n    function transferFrom(address, address, uint256) external returns (bool);\\n}\\n\\n/// All the errors which may be encountered on the bond manager\\nlibrary Errors {\\n    string constant ERC20_ERR = \\\"BondManager: Could not post bond\\\";\\n    string constant ALREADY_FINALIZED = \\\"BondManager: Fraud proof for this pre-state root has already been finalized\\\";\\n    string constant SLASHED = \\\"BondManager: Cannot finalize withdrawal, you probably got slashed\\\";\\n    string constant WRONG_STATE = \\\"BondManager: Wrong bond state for proposer\\\";\\n    string constant CANNOT_CLAIM = \\\"BondManager: Cannot claim yet. Dispute must be finalized first\\\";\\n\\n    string constant WITHDRAWAL_PENDING = \\\"BondManager: Withdrawal already pending\\\";\\n    string constant TOO_EARLY = \\\"BondManager: Too early to finalize your withdrawal\\\";\\n\\n    string constant ONLY_TRANSITIONER = \\\"BondManager: Only the transitioner for this pre-state root may call this function\\\";\\n    string constant ONLY_FRAUD_VERIFIER = \\\"BondManager: Only the fraud verifier may call this function\\\";\\n    string constant ONLY_STATE_COMMITMENT_CHAIN = \\\"BondManager: Only the state commitment chain may call this function\\\";\\n    string constant WAIT_FOR_DISPUTES = \\\"BondManager: Wait for other potential disputes\\\";\\n}\\n\\n/**\\n * @title iOVM_BondManager\\n */\\ninterface iOVM_BondManager {\\n\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    /// The lifecycle of a proposer's bond\\n    enum State {\\n        // Before depositing or after getting slashed, a user is uncollateralized\\n        NOT_COLLATERALIZED,\\n        // After depositing, a user is collateralized\\n        COLLATERALIZED,\\n        // After a user has initiated a withdrawal\\n        WITHDRAWING\\n    }\\n\\n    /// A bond posted by a proposer\\n    struct Bond {\\n        // The user's state\\n        State state;\\n        // The timestamp at which a proposer issued their withdrawal request\\n        uint32 withdrawalTimestamp;\\n        // The time when the first disputed was initiated for this bond\\n        uint256 firstDisputeAt;\\n        // The earliest observed state root for this bond which has had fraud\\n        bytes32 earliestDisputedStateRoot;\\n        // The state root's timestamp\\n        uint256 earliestTimestamp;\\n    }\\n\\n    // Per pre-state root, store the number of state provisions that were made\\n    // and how many of these calls were made by each user. Payouts will then be\\n    // claimed by users proportionally for that dispute.\\n    struct Rewards {\\n        // Flag to check if rewards for a fraud proof are claimable\\n        bool canClaim;\\n        // Total number of `recordGasSpent` calls made\\n        uint256 total;\\n        // The gas spent by each user to provide witness data. The sum of all\\n        // values inside this map MUST be equal to the value of `total`\\n        mapping(address => uint256) gasSpent;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function recordGasSpent(\\n        bytes32 _preStateRoot,\\n        bytes32 _txHash,\\n        address _who,\\n        uint256 _gasSpent\\n    ) external;\\n\\n    function finalize(\\n        bytes32 _preStateRoot,\\n        address _publisher,\\n        uint256 _timestamp\\n    ) external;\\n\\n    function deposit() external;\\n\\n    function startWithdrawal() external;\\n\\n    function finalizeWithdrawal() external;\\n\\n    function claim(\\n        address _who\\n    ) external;\\n\\n    function isCollateralized(\\n        address _who\\n    ) external view returns (bool);\\n\\n    function getGasSpent(\\n        bytes32 _preStateRoot,\\n        address _who\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x3c2a8a399487857158649db1896749d86e39cba545a8aeb2e2bb0f3bdfa7a5b1\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/verification/iOVM_FraudVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_StateTransitioner } from \\\"./iOVM_StateTransitioner.sol\\\";\\n\\n/**\\n * @title iOVM_FraudVerifier\\n */\\ninterface iOVM_FraudVerifier {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event FraudProofInitialized(\\n        bytes32 _preStateRoot,\\n        uint256 _preStateRootIndex,\\n        bytes32 _transactionHash,\\n        address _who\\n    );\\n\\n    event FraudProofFinalized(\\n        bytes32 _preStateRoot,\\n        uint256 _preStateRootIndex,\\n        bytes32 _transactionHash,\\n        address _who\\n    );\\n\\n\\n    /***************************************\\n     * Public Functions: Transition Status *\\n     ***************************************/\\n\\n    function getStateTransitioner(bytes32 _preStateRoot, bytes32 _txHash) external view returns (iOVM_StateTransitioner _transitioner);\\n\\n\\n    /****************************************\\n     * Public Functions: Fraud Verification *\\n     ****************************************/\\n\\n    function initializeFraudVerification(\\n        bytes32 _preStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\\n        Lib_OVMCodec.Transaction calldata _transaction,\\n        Lib_OVMCodec.TransactionChainElement calldata _txChainElement,\\n        Lib_OVMCodec.ChainBatchHeader calldata _transactionBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _transactionProof\\n    ) external;\\n\\n    function finalizeFraudVerification(\\n        bytes32 _preStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\\n        bytes32 _txHash,\\n        bytes32 _postStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader calldata _postStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _postStateRootProof\\n    ) external;\\n}\\n\",\"keccak256\":\"0x5efd7bb18164bbd3e9d58379e8203fbf2a7ee802b1a48dff3ceaaec1523b1751\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/verification/iOVM_StateTransitioner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title iOVM_StateTransitioner\\n */\\ninterface iOVM_StateTransitioner {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AccountCommitted(\\n        address _address\\n    );\\n\\n    event ContractStorageCommitted(\\n        address _address,\\n        bytes32 _key\\n    );\\n\\n\\n    /**********************************\\n     * Public Functions: State Access *\\n     **********************************/\\n\\n    function getPreStateRoot() external view returns (bytes32 _preStateRoot);\\n    function getPostStateRoot() external view returns (bytes32 _postStateRoot);\\n    function isComplete() external view returns (bool _complete);\\n\\n\\n    /***********************************\\n     * Public Functions: Pre-Execution *\\n     ***********************************/\\n\\n    function proveContractState(\\n        address _ovmContractAddress,\\n        address _ethContractAddress,\\n        bytes calldata _stateTrieWitness\\n    ) external;\\n\\n    function proveStorageSlot(\\n        address _ovmContractAddress,\\n        bytes32 _key,\\n        bytes calldata _storageTrieWitness\\n    ) external;\\n\\n\\n    /*******************************\\n     * Public Functions: Execution *\\n     *******************************/\\n\\n    function applyTransaction(\\n        Lib_OVMCodec.Transaction calldata _transaction\\n    ) external;\\n\\n\\n    /************************************\\n     * Public Functions: Post-Execution *\\n     ************************************/\\n\\n    function commitContractState(\\n        address _ovmContractAddress,\\n        bytes calldata _stateTrieWitness\\n    ) external;\\n\\n    function commitStorageSlot(\\n        address _ovmContractAddress,\\n        bytes32 _key,\\n        bytes calldata _storageTrieWitness\\n    ) external;\\n\\n\\n    /**********************************\\n     * Public Functions: Finalization *\\n     **********************************/\\n\\n    function completeTransition() external;\\n}\\n\",\"keccak256\":\"0x3d044ac0a3bb6ad3d529f904b3191117511f9c379678ca03010e1ebdfcb5c34b\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/verification/iOVM_StateTransitionerFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Contract Imports */\\nimport { iOVM_StateTransitioner } from \\\"./iOVM_StateTransitioner.sol\\\";\\n\\n/**\\n * @title iOVM_StateTransitionerFactory\\n */\\ninterface iOVM_StateTransitionerFactory {\\n\\n    /***************************************\\n     * Public Functions: Contract Creation *\\n     ***************************************/\\n\\n    function create(\\n        address _proxyManager,\\n        uint256 _stateTransitionIndex,\\n        bytes32 _preStateRoot,\\n        bytes32 _transactionHash\\n    )\\n        external\\n        returns (\\n            iOVM_StateTransitioner _ovmStateTransitioner\\n        );\\n}\\n\",\"keccak256\":\"0x60a0f0c104e4c0c7863268a93005762e8146d393f9cfddfdd6a2d6585c5911fc\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/codec/Lib_OVMCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\nimport { Lib_SafeExecutionManagerWrapper } from \\\"../../libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    bytes constant internal RLP_NULL_BYTES = hex'80';\\n    bytes constant internal NULL_BYTES = bytes('');\\n\\n    // Ring buffer IDs\\n    bytes32 constant internal RING_BUFFER_SCC_BATCHES = keccak256(\\\"RING_BUFFER_SCC_BATCHES\\\");\\n    bytes32 constant internal RING_BUFFER_CTC_BATCHES = keccak256(\\\"RING_BUFFER_CTC_BATCHES\\\");\\n    bytes32 constant internal RING_BUFFER_CTC_QUEUE = keccak256(\\\"RING_BUFFER_CTC_QUEUE\\\");\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum EOASignatureType {\\n        EIP155_TRANSACTON,\\n        ETH_SIGNED_MESSAGE\\n    }\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Account {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n        address ethAddress;\\n        bool isFresh;\\n    }\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex;  // QUEUED TX ONLY\\n        uint256 timestamp;   // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData;        // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 queueRoot;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n    struct EIP155Transaction {\\n        uint256 nonce;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        uint256 chainId;\\n    }\\n\\n\\n    /*********************************************\\n     * Internal Functions: Encoding and Decoding *\\n     *********************************************/\\n\\n    /**\\n     * Decodes an EOA transaction (i.e., native Ethereum RLP encoding).\\n     * @param _transaction Encoded EOA transaction.\\n     * @return _decoded Transaction decoded into a struct.\\n     */\\n    function decodeEIP155Transaction(\\n        bytes memory _transaction,\\n        bool _isEthSignedMessage\\n    )\\n        internal\\n        pure\\n        returns (\\n            EIP155Transaction memory _decoded\\n        )\\n    {\\n        if (_isEthSignedMessage) {\\n            (\\n                uint256 _nonce,\\n                uint256 _gasLimit,\\n                uint256 _gasPrice,\\n                uint256 _chainId,\\n                address _to,\\n                bytes memory _data\\n            ) = abi.decode(\\n                _transaction,\\n                (uint256, uint256, uint256, uint256, address ,bytes)\\n            );\\n            return EIP155Transaction({\\n                nonce: _nonce,\\n                gasPrice: _gasPrice,\\n                gasLimit: _gasLimit,\\n                to: _to,\\n                value: 0,\\n                data: _data,\\n                chainId: _chainId\\n            });\\n        } else {\\n            Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_transaction);\\n\\n            return EIP155Transaction({\\n                nonce: Lib_RLPReader.readUint256(decoded[0]),\\n                gasPrice: Lib_RLPReader.readUint256(decoded[1]),\\n                gasLimit: Lib_RLPReader.readUint256(decoded[2]),\\n                to: Lib_RLPReader.readAddress(decoded[3]),\\n                value: Lib_RLPReader.readUint256(decoded[4]),\\n                data: Lib_RLPReader.readBytes(decoded[5]),\\n                chainId:  Lib_RLPReader.readUint256(decoded[6])\\n            });\\n        }\\n    }\\n\\n    function decompressEIP155Transaction(\\n        bytes memory _transaction\\n    )\\n        internal\\n        returns (\\n            EIP155Transaction memory _decompressed\\n        )\\n    {\\n        return EIP155Transaction({\\n            gasLimit: Lib_BytesUtils.toUint24(_transaction, 0),\\n            gasPrice: uint256(Lib_BytesUtils.toUint24(_transaction, 3)) * 1000000,\\n            nonce: Lib_BytesUtils.toUint24(_transaction, 6),\\n            to: Lib_BytesUtils.toAddress(_transaction, 9),\\n            data: Lib_BytesUtils.slice(_transaction, 29),\\n            chainId: Lib_SafeExecutionManagerWrapper.safeCHAINID(),\\n            value: 0\\n        });\\n    }\\n\\n    /**\\n     * Encodes an EOA transaction back into the original transaction.\\n     * @param _transaction EIP155transaction to encode.\\n     * @param _isEthSignedMessage Whether or not this was an eth signed message.\\n     * @return Encoded transaction.\\n     */\\n    function encodeEIP155Transaction(\\n        EIP155Transaction memory _transaction,\\n        bool _isEthSignedMessage\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_isEthSignedMessage) {\\n            return abi.encode(\\n                _transaction.nonce,\\n                _transaction.gasLimit,\\n                _transaction.gasPrice,\\n                _transaction.chainId,\\n                _transaction.to,\\n                _transaction.data\\n            );\\n        } else {\\n            bytes[] memory raw = new bytes[](9);\\n\\n            raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\\n            raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\\n            raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\\n            if (_transaction.to == address(0)) {\\n                raw[3] = Lib_RLPWriter.writeBytes('');\\n            } else {\\n                raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\\n            }\\n            raw[4] = Lib_RLPWriter.writeUint(0);\\n            raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId);\\n            raw[7] = Lib_RLPWriter.writeBytes(bytes(''));\\n            raw[8] = Lib_RLPWriter.writeBytes(bytes(''));\\n\\n            return Lib_RLPWriter.writeList(raw);\\n        }\\n    }\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return _encoded Encoded transaction bytes.\\n     */\\n    function encodeTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        return abi.encodePacked(\\n            _transaction.timestamp,\\n            _transaction.blockNumber,\\n            _transaction.l1QueueOrigin,\\n            _transaction.l1TxOrigin,\\n            _transaction.entrypoint,\\n            _transaction.gasLimit,\\n            _transaction.data\\n        );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return _hash Hashed transaction\\n     */\\n    function hashTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * Converts an OVM account to an EVM account.\\n     * @param _in OVM account to convert.\\n     * @return _out Converted EVM account.\\n     */\\n    function toEVMAccount(\\n        Account memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory _out\\n        )\\n    {\\n        return EVMAccount({\\n            nonce: _in.nonce,\\n            balance: _in.balance,\\n            storageRoot: _in.storageRoot,\\n            codeHash: _in.codeHash\\n        });\\n    }\\n\\n    /**\\n     * @notice RLP-encodes an account state struct.\\n     * @param _account Account state struct.\\n     * @return _encoded RLP-encoded account state.\\n     */\\n    function encodeEVMAccount(\\n        EVMAccount memory _account\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](4);\\n\\n        // Unfortunately we can't create this array outright because\\n        // Lib_RLPWriter.writeList will reject fixed-size arrays. Assigning\\n        // index-by-index circumvents this issue.\\n        raw[0] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.nonce)\\n            )\\n        );\\n        raw[1] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.balance)\\n            )\\n        );\\n        raw[2] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.storageRoot));\\n        raw[3] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.codeHash));\\n\\n        return Lib_RLPWriter.writeList(raw);\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return _account Account state struct.\\n     */\\n    function decodeEVMAccount(\\n        bytes memory _encoded\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory _account\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return EVMAccount({\\n            nonce: Lib_RLPReader.readUint256(accountState[0]),\\n            balance: Lib_RLPReader.readUint256(accountState[1]),\\n            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n            codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n        });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return _hash Hash of the header.\\n     */\\n    function hashBatchHeader(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(\\n            abi.encode(\\n                _batchHeader.batchRoot,\\n                _batchHeader.batchSize,\\n                _batchHeader.prevTotalElements,\\n                _batchHeader.extraData\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x19d78734777b4998f1544e235cf3934f20c5055cd76c2bd60bf0f6dacdd72b3a\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// +build ovm\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Contract Imports */\\nimport { Ownable } from \\\"./Lib_Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string _name,\\n        address _newAddress\\n    );\\n\\n    /*******************************************\\n     * Contract Variables: Internal Accounting *\\n     *******************************************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        public\\n        onlyOwner\\n    {\\n        emit AddressSet(_name, _address);\\n        addresses[_getNameHash(_name)] = _address;\\n    }\\n\\n    function getAddress(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (address)\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _hash\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0xdf802e1cc6474df913626991e9fca3835c620a519f397afe04bf9c260e723257\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// +build ovm\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\ncontract Lib_AddressResolver {\\n\\n    /*******************************************\\n     * Contract Variables: Contract References *\\n     *******************************************/\\n\\n    Lib_AddressManager internal libAddressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    ) public {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function resolve(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (\\n            address _contract\\n        )\\n    {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0xf3b9d78b309ddeec259ce3e0e1cfdef3ca40938e9a81971b28ce2b8ea327f533\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// +build ovm\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Ownable\\n * @dev Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n */\\nabstract contract Ownable {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    address public owner;\\n\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor() internal {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    modifier onlyOwner() {\\n        require(\\n            owner == msg.sender,\\n            \\\"Ownable: caller is not the owner\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function renounceOwnership()\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        emit OwnershipTransferred(owner, address(0));\\n        owner = address(0);\\n    }\\n\\n    function transferOwnership(address _newOwner)\\n        public\\n        virtual\\n        onlyOwner\\n    {\\n        require(\\n            _newOwner != address(0),\\n            \\\"Ownable: new owner cannot be the zero address\\\"\\n        );\\n\\n        emit OwnershipTransferred(owner, _newOwner);\\n        owner = _newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0xe0409fbd236d16ca6be439d9d97dd36d0d9a0697ee0062d49588b9d29c248e47\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant internal MAX_LIST_LENGTH = 32;\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    \\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n    \\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n    \\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem memory\\n        )\\n    {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({\\n            length: _in.length,\\n            ptr: ptr\\n        });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        (\\n            uint256 listOffset,\\n            ,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"Invalid RLP list value.\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(\\n                itemCount < MAX_LIST_LENGTH,\\n                \\\"Provided RLP list exceeds max list length.\\\"\\n            );\\n\\n            (\\n                uint256 itemOffset,\\n                uint256 itemLength,\\n            ) = _decodeLength(RLPItem({\\n                length: _in.length - offset,\\n                ptr: _in.ptr + offset\\n            }));\\n\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: _in.ptr + offset\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        return readList(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes value.\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return readBytes(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return readString(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _in.length <= 33,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return readBytes32(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return readUint256(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _in.length == 1,\\n            \\\"Invalid RLP boolean value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return readBool(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(\\n            _in.length == 21,\\n            \\\"Invalid RLP address value.\\\"\\n        );\\n\\n        return address(readUint256(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return readAddress(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(\\n            _in.length > 0,\\n            \\\"RLP item cannot be null.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n            \\n            require(\\n                _in.length > strLen,\\n                \\\"Invalid RLP short string.\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"Invalid RLP long string length.\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfStrLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"Invalid RLP long string.\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"Invalid RLP short list.\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"Invalid RLP long list length.\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfListLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"Invalid RLP long list.\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\\n        assembly {\\n            mstore(\\n                dest,\\n                or(\\n                    and(mload(src), not(mask)),\\n                    and(mload(dest), mask)\\n                )\\n            )\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0x8338f7b6e5f0ded8fc36d9088fd127ee53ae4040ca3f4838eb6123f642d38c62\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = Lib_BytesUtils.concat(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return _out The RLP encoded list of items in bytes.\\n     */\\n    function writeList(\\n        bytes[] memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory list = _flatten(_in);\\n        return Lib_BytesUtils.concat(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeString(\\n        string memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return _out The RLP encoded address in bytes.\\n     */\\n    function writeAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return _out The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(\\n        uint256 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return _out The RLP encoded bool in bytes.\\n     */\\n    function writeBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return _encoded RLP encoded bytes.\\n     */\\n    function _writeLength(\\n        uint256 _len,\\n        uint256 _offset\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return _binary RLP encoded bytes.\\n     */\\n    function _toBinary(\\n        uint256 _x\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _binary\\n        )\\n    {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    )\\n        private\\n        pure\\n    {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return _flattened The flattened byte string.\\n     */\\n    function _flatten(\\n        bytes[] memory _list\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _flattened\\n        )\\n    {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\",\"keccak256\":\"0x6d1aaef567f8a91bb965b95a95637f433a1f0ac4cf0bc1e209cdb1dd5b0f204b\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function toBool(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _out\\n        )\\n    {\\n        return _in != 0;\\n    }\\n\\n    function fromBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _out\\n        )\\n    {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    function toAddress(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address _out\\n        )\\n    {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    function fromAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _out\\n        )\\n    {\\n        return bytes32(uint256(_in));\\n    }\\n\\n    function removeLeadingZeros(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory out;\\n\\n        assembly {\\n            // Figure out how many leading zero bytes to remove.\\n            let shift := 0\\n            for { let i := 0 } and(lt(i, 32), eq(byte(i, _in), 0)) { i := add(i, 1) } {\\n                shift := add(shift, 1)\\n            }\\n\\n            // Reserve some space for our output and fix the free memory pointer.\\n            out := mload(0x40)\\n            mstore(0x40, add(out, 0x40))\\n\\n            // Shift the value and store it into the output bytes.\\n            mstore(add(out, 0x20), shl(mul(shift, 8), _in))\\n\\n            // Store the new size (with leading zero bytes removed) in the output byte size.\\n            mstore(out, sub(32, shift))\\n        }\\n\\n        return out;\\n    }\\n}\\n\",\"keccak256\":\"0x06f97590a80a01daa3bf6aa795449aea91a78684c646b4a6caeece8ef919c80c\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (_bytes.length - _start == 0) {\\n            return bytes('');\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32PadLeft(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 ret;\\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\\n        assembly {\\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\\n        }\\n        return ret;\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3 , \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(\\n        bytes memory _bytes,\\n        bytes memory _other\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0x849e4fedd81cd260e4c3b74b953f00636323574c60d363f36ab331e94aab9219\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/wrappers/Lib_SafeExecutionManagerWrapper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n/**\\n * @title Lib_SafeExecutionManagerWrapper\\n */\\nlibrary Lib_SafeExecutionManagerWrapper {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Makes an ovmCALL and performs all the necessary safety checks.\\n     * @param _gasLimit Gas limit for the call.\\n     * @param _target Address to call.\\n     * @param _calldata Data to send to the call.\\n     * @return _success Whether or not the call reverted.\\n     * @return _returndata Data returned by the call.\\n     */\\n    function safeCALL(\\n        uint256 _gasLimit,\\n        address _target,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCALL(uint256,address,bytes)\\\",\\n                _gasLimit,\\n                _target,\\n                _calldata\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bool, bytes));\\n    }\\n\\n    /**\\n     * Makes an ovmCALL and performs all the necessary safety checks.\\n     * @param _gasLimit Gas limit for the call.\\n     * @param _target Address to call.\\n     * @param _calldata Data to send to the call.\\n     * @return _success Whether or not the call reverted.\\n     * @return _returndata Data returned by the call.\\n     */\\n    function safeDELEGATECALL(\\n        uint256 _gasLimit,\\n        address _target,\\n        bytes memory _calldata\\n    )\\n        internal\\n        returns (\\n            bool _success,\\n            bytes memory _returndata\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmDELEGATECALL(uint256,address,bytes)\\\",\\n                _gasLimit,\\n                _target,\\n                _calldata\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bool, bytes));\\n    }\\n\\n    /**\\n     * Performs an ovmCREATE and the necessary safety checks.\\n     * @param _gasLimit Gas limit for the creation.\\n     * @param _bytecode Code for the new contract.\\n     * @return _contract Address of the created contract.\\n     */\\n    function safeCREATE(\\n        uint256 _gasLimit,\\n        bytes memory _bytecode\\n    )\\n        internal\\n        returns (\\n            address _contract\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            _gasLimit,\\n            abi.encodeWithSignature(\\n                \\\"ovmCREATE(bytes)\\\",\\n                _bytecode\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs an ovmEXTCODESIZE and the necessary safety checks.\\n     * @param _contract Address of the contract to query the size of.\\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\\n     */\\n    function safeEXTCODESIZE(\\n        address _contract\\n    )\\n        internal\\n        returns (\\n            uint256 _EXTCODESIZE\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmEXTCODESIZE(address)\\\",\\n                _contract\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCHAINID call.\\n     * @return _CHAINID Result of calling ovmCHAINID.\\n     */\\n    function safeCHAINID()\\n        internal\\n        returns (\\n            uint256 _CHAINID\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCHAINID()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmCALLER call.\\n     * @return _CALLER Result of calling ovmCALLER.\\n     */\\n    function safeCALLER()\\n        internal\\n        returns (\\n            address _CALLER\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCALLER()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs a safe ovmADDRESS call.\\n     * @return _ADDRESS Result of calling ovmADDRESS.\\n     */\\n    function safeADDRESS()\\n        internal\\n        returns (\\n            address _ADDRESS\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmADDRESS()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * Performs a safe ovmGETNONCE call.\\n     * @return _nonce Result of calling ovmGETNONCE.\\n     */\\n    function safeGETNONCE()\\n        internal\\n        returns (\\n            uint256 _nonce\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmGETNONCE()\\\"\\n            )\\n        );\\n\\n        return abi.decode(returndata, (uint256));\\n    }\\n\\n    /**\\n     * Performs a safe ovmSETNONCE call.\\n     * @param _nonce New account nonce.\\n     */\\n    function safeSETNONCE(\\n        uint256 _nonce\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSETNONCE(uint256)\\\",\\n                _nonce\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe ovmCREATEEOA call.\\n     * @param _messageHash Message hash which was signed by EOA\\n     * @param _v v value of signature (0 or 1)\\n     * @param _r r value of signature\\n     * @param _s s value of signature\\n     */\\n    function safeCREATEEOA(\\n        bytes32 _messageHash,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\\\",\\n                _messageHash,\\n                _v,\\n                _r,\\n                _s\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe REVERT.\\n     * @param _reason String revert reason to pass along with the REVERT.\\n     */\\n    function safeREVERT(\\n        string memory _reason\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmREVERT(bytes)\\\",\\n                bytes(_reason)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Performs a safe \\\"require\\\".\\n     * @param _condition Boolean condition that must be true or will revert.\\n     * @param _reason String revert reason to pass along with the REVERT.\\n     */\\n    function safeREQUIRE(\\n        bool _condition,\\n        string memory _reason\\n    )\\n        internal\\n    {\\n        if (!_condition) {\\n            safeREVERT(\\n                _reason\\n            );\\n        }\\n    }\\n\\n    /**\\n     * Performs a safe ovmSLOAD call.\\n     */\\n    function safeSLOAD(\\n        bytes32 _key\\n    )\\n        internal\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes memory returndata = _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSLOAD(bytes32)\\\",\\n                _key\\n            )\\n        );\\n\\n        return abi.decode(returndata, (bytes32));\\n    }\\n\\n    /**\\n     * Performs a safe ovmSSTORE call.\\n     */\\n    function safeSSTORE(\\n        bytes32 _key,\\n        bytes32 _value\\n    )\\n        internal\\n    {\\n        _safeExecutionManagerInteraction(\\n            abi.encodeWithSignature(\\n                \\\"ovmSSTORE(bytes32,bytes32)\\\",\\n                _key,\\n                _value\\n            )\\n        );\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Performs an ovm interaction and the necessary safety checks.\\n     * @param _gasLimit Gas limit for the interaction.\\n     * @param _calldata Data to send to the OVM_ExecutionManager (encoded with sighash).\\n     * @return _returndata Data sent back by the OVM_ExecutionManager.\\n     */\\n    function _safeExecutionManagerInteraction(\\n        uint256 _gasLimit,\\n        bytes memory _calldata\\n    )\\n        private\\n        returns (\\n            bytes memory _returndata\\n        )\\n    {\\n        address ovmExecutionManager = msg.sender;\\n        (\\n            bool success,\\n            bytes memory returndata\\n        ) = ovmExecutionManager.call{gas: _gasLimit}(_calldata);\\n\\n        if (success == false) {\\n            assembly {\\n                revert(add(returndata, 0x20), mload(returndata))\\n            }\\n        } else if (returndata.length == 1) {\\n            assembly {\\n                return(0, 1)\\n            }\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    function _safeExecutionManagerInteraction(\\n        bytes memory _calldata\\n    )\\n        private\\n        returns (\\n            bytes memory _returndata\\n        )\\n    {\\n        return _safeExecutionManagerInteraction(\\n            gasleft(),\\n            _calldata\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xdc30487ca1580f3498d4a1c4e26dc53158c00b44bd72da212a66267c22a139b0\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161181238038061181283398101604081905261002f91610054565b600080546001600160a01b0319166001600160a01b0392909216919091179055610082565b600060208284031215610065578081fd5b81516001600160a01b038116811461007b578182fd5b9392505050565b611781806100916000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063461a44781461005157806398d8867d1461007a578063a286ba1c1461008f578063b48ec820146100a2575b600080fd5b61006461005f3660046110d2565b6100b5565b60405161007191906112d7565b60405180910390f35b61008d610088366004610ffa565b610193565b005b61008d61009d366004610f35565b6104d2565b6100646100b0366004610f14565b61088c565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b838110156101155781810151838201526020016100fd565b50505050905090810190601f1680156101425780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561015f57600080fd5b505afa158015610173573d6000803e3d6000fd5b505050506040513d602081101561018957600080fd5b505190505b919050565b8661019d856108db565b60005a905060006101ad886108db565b90506101b98b826108f4565b156101c45750610410565b60006101ff6040518060400160405280601881526020017727ab26afa9ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760411b8152506100b5565b905060006102416040518060400160405280601d81526020017f4f564d5f43616e6f6e6963616c5472616e73616374696f6e436861696e0000008152506100b5565b9050816001600160a01b0316634d69ee578e8e8e6040518463ffffffff1660e01b815260040161027393929190611330565b60206040518083038186803b15801561028b57600080fd5b505afa15801561029f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c39190610ee0565b6102e85760405162461bcd60e51b81526004016102df906115b8565b60405180910390fd5b6040516326f2b4e760e11b81526001600160a01b03821690634de569ce9061031a908d908d908d908d90600401611612565b60206040518083038186803b15801561033257600080fd5b505afa158015610346573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036a9190610ee0565b6103865760405162461bcd60e51b81526004016102df9061146a565b86600001518860600151018b600001518d6060015101600101146103bc5760405162461bcd60e51b81526004016102df906114f6565b6103cb8d848d60000151610913565b7f41a48bde2468fac6f670f39b66d7b91f311053e1f28eab9d75056546e6eaac958d8c6000015185336040516104049493929190611365565b60405180910390a15050505b60005a820390506104476040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b8152506100b5565b6001600160a01b0316631e16e92f858533856040518563ffffffff1660e01b815260040180858152602001848152602001836001600160a01b03168152602001828152602001945050505050600060405180830381600087803b1580156104ad57600080fd5b505af11580156104c1573d6000803e3d6000fd5b505050505050505050505050505050565b868460005a905060006104e58b8961088c565b905060006105226040518060400160405280601881526020017727ab26afa9ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760411b8152506100b5565b905060006105566040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b8152506100b5565b9050826001600160a01b031663b2fa1c9e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561059157600080fd5b505afa1580156105a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105c99190610ee0565b15156001146105ea5760405162461bcd60e51b81526004016102df90611389565b8a600001518c60600151016001018760000151896060015101146106205760405162461bcd60e51b81526004016102df906113f0565b816001600160a01b0316634d69ee578e8e8e6040518463ffffffff1660e01b815260040161065093929190611330565b60206040518083038186803b15801561066857600080fd5b505afa15801561067c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106a09190610ee0565b6106bc5760405162461bcd60e51b81526004016102df906115b8565b604051634d69ee5760e01b81526001600160a01b03831690634d69ee57906106ec908c908c908c90600401611330565b60206040518083038186803b15801561070457600080fd5b505afa158015610718573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073c9190610ee0565b6107585760405162461bcd60e51b81526004016102df906114ae565b826001600160a01b031663c1c618b86040518163ffffffff1660e01b815260040160206040518083038186803b15801561079157600080fd5b505afa1580156107a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c99190610efc565b8914156107e85760405162461bcd60e51b81526004016102df90611568565b6107f2888e610a3e565b6000600160008f8d60405160200161080b92919061125a565b60405160208183030381529060405280519060200120815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055507f1e5fff3c23daf51ea67aaa3bbc738bcedaa98be5a5503f0e63a336a004b075b18d8c600001518c336040516104049493929190611365565b60006001600084846040516020016108a592919061125a565b60408051808303601f19018152918152815160209283012083529082019290925201600020546001600160a01b03169392505050565b60006108e682610b98565b805190602001209050919050565b600080610901848461088c565b6001600160a01b031614159392505050565b6109516040518060400160405280601c81526020017f4f564d5f53746174655472616e736974696f6e6572466163746f7279000000008152506100b5565b600054604051631168a38160e11b81526001600160a01b03928316926322d1470292610988929116908590889088906004016112eb565b602060405180830381600087803b1580156109a257600080fd5b505af11580156109b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109da91906110b6565b6001600085856040516020016109f192919061125a565b60405160208183030381529060405280519060200120815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505050565b6000610a796040518060400160405280601881526020017727ab26afa9ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760411b8152506100b5565b90506000610aad6040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b8152506100b5565b604051632e38626b60e21b81529091506001600160a01b0383169063b8e189ac90610adc9087906004016115ff565b600060405180830381600087803b158015610af657600080fd5b505af1158015610b0a573d6000803e3d6000fd5b505050506000808560800151806020019051810190610b299190611120565b60405163abfbbe1360e01b815291935091506001600160a01b0384169063abfbbe1390610b5e90889085908790600401611311565b600060405180830381600087803b158015610b7857600080fd5b505af1158015610b8c573d6000803e3d6000fd5b50505050505050505050565b6060816000015182602001518360400151846060015185608001518660a001518760c00151604051602001610bd39796959493929190611268565b6040516020818303038152906040529050919050565b600067ffffffffffffffff831115610bfd57fe5b610c10601f8401601f19166020016116d1565b9050828152838383011115610c2457600080fd5b828260208301376000602084830101529392505050565b803561018e81611725565b600082601f830112610c56578081fd5b610c6583833560208501610be9565b9392505050565b80356002811061018e57600080fd5b600060a08284031215610c8c578081fd5b60405160a0810167ffffffffffffffff8282108183111715610caa57fe5b81604052829350843583526020850135602084015260408501356040840152606085013560608401526080850135915080821115610ce757600080fd5b50610cf485828601610c46565b6080830152505092915050565b600060408284031215610d12578081fd5b6040516040810167ffffffffffffffff8282108183111715610d3057fe5b8160405282935084358352602091508185013581811115610d5057600080fd5b8501601f81018713610d6157600080fd5b803582811115610d6d57fe5b8381029250610d7d8484016116d1565b8181528481019083860185850187018b1015610d9857600080fd5b600095505b83861015610dbb578035835260019590950194918601918601610d9d565b5080868801525050505050505092915050565b600060a08284031215610ddf578081fd5b60405160a0810167ffffffffffffffff8282108183111715610dfd57fe5b8160405282935084359150610e118261173d565b8183526020850135602084015260408501356040840152606085013560608401526080850135915080821115610ce757600080fd5b600060e08284031215610e57578081fd5b610e6160e06116d1565b90508135815260208201356020820152610e7d60408301610c6c565b6040820152610e8e60608301610c3b565b6060820152610e9f60808301610c3b565b608082015260a082013560a082015260c082013567ffffffffffffffff811115610ec857600080fd5b610ed484828501610c46565b60c08301525092915050565b600060208284031215610ef1578081fd5b8151610c658161173d565b600060208284031215610f0d578081fd5b5051919050565b60008060408385031215610f26578081fd5b50508035926020909101359150565b600080600080600080600060e0888a031215610f4f578283fd5b87359650602088013567ffffffffffffffff80821115610f6d578485fd5b610f798b838c01610c7b565b975060408a0135915080821115610f8e578485fd5b610f9a8b838c01610d01565b965060608a0135955060808a0135945060a08a0135915080821115610fbd578384fd5b610fc98b838c01610c7b565b935060c08a0135915080821115610fde578283fd5b50610feb8a828b01610d01565b91505092959891949750929550565b600080600080600080600060e0888a031215611014578081fd5b87359650602088013567ffffffffffffffff80821115611032578283fd5b61103e8b838c01610c7b565b975060408a0135915080821115611053578283fd5b61105f8b838c01610d01565b965060608a0135915080821115611074578283fd5b6110808b838c01610e46565b955060808a0135915080821115611095578283fd5b6110a18b838c01610dce565b945060a08a0135915080821115610fbd578283fd5b6000602082840312156110c7578081fd5b8151610c6581611725565b6000602082840312156110e3578081fd5b813567ffffffffffffffff8111156110f9578182fd5b8201601f81018413611109578182fd5b61111884823560208401610be9565b949350505050565b60008060408385031215611132578182fd5b82519150602083015161114481611725565b809150509250929050565b6001600160a01b03169052565b600081518084526111748160208601602086016116f5565b601f01601f19169290920160200192915050565b600081518352602082015160208401526040820151604084015260608201516060840152608082015160a0608085015261111860a085018261115c565b6000604083018251845260208084015160408287015282815180855260608801915083830194508592505b8083101561121057845182529383019360019290920191908301906111f0565b509695505050505050565b6000815115158352602082015160208401526040820151604084015260608201516060840152608082015160a0608085015261111860a085018261115c565b918252602082015260400190565b60008882528760208301526002871061127d57fe5b8660f81b60408301526bffffffffffffffffffffffff19808760601b166041840152808660601b1660558401525083606983015282516112c48160898501602087016116f5565b9190910160890198975050505050505050565b6001600160a01b0391909116815260200190565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b9283526001600160a01b03919091166020830152604082015260600190565b6000848252606060208301526113496060830185611188565b828103604084015261135b81856111c5565b9695505050505050565b938452602084019290925260408301526001600160a01b0316606082015260800190565b60208082526041908201527f5374617465207472616e736974696f6e2070726f63657373206d75737420626560408201527f20636f6d706c65746564207072696f7220746f2066696e616c697a6174696f6e6060820152601760f91b608082015260a00190565b60208082526054908201527f506f73742d737461746520726f6f7420676c6f62616c20696e646578206d757360408201527f7420657175616c20746f207468652070726520737461746520726f6f7420676c60608201527337b130b61034b73232bc1038363ab99037b7329760611b608082015260a00190565b60208082526024908201527f496e76616c6964207472616e73616374696f6e20696e636c7573696f6e20707260408201526337b7b31760e11b606082015260800190565b60208082526028908201527f496e76616c696420706f73742d737461746520726f6f7420696e636c7573696f6040820152673710383937b7b31760c11b606082015260800190565b6020808252604c908201527f5072652d737461746520726f6f7420676c6f62616c20696e646578206d75737460408201527f20657175616c20746f20746865207472616e73616374696f6e20726f6f74206760608201526b3637b130b61034b73232bc1760a11b608082015260a00190565b60208082526030908201527f5374617465207472616e736974696f6e20686173206e6f74206265656e20707260408201526f37bb32b710333930bab23ab632b73a1760811b606082015260800190565b60208082526027908201527f496e76616c6964207072652d737461746520726f6f7420696e636c7573696f6e60408201526610383937b7b31760c91b606082015260800190565b600060208252610c656020830184611188565b60006080825285516080830152602086015160a083015260408601516002811061163857fe5b60c083015260608601516001600160a01b031660e0830152608086015161166361010084018261114f565b5060a086015161012083015260c086015160e061014084015261168a61016084018261115c565b9050828103602084015261169e818761121b565b905082810360408401526116b28186611188565b905082810360608401526116c681856111c5565b979650505050505050565b60405181810167ffffffffffffffff811182821017156116ed57fe5b604052919050565b60005b838110156117105781810151838201526020016116f8565b8381111561171f576000848401525b50505050565b6001600160a01b038116811461173a57600080fd5b50565b801515811461173a57600080fdfea2646970667358221220ab02b9a67a211940c347821f42d6dbba1dfaf13e125f2924fb49f5ab8a0ff88c64736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c8063461a44781461005157806398d8867d1461007a578063a286ba1c1461008f578063b48ec820146100a2575b600080fd5b61006461005f3660046110d2565b6100b5565b60405161007191906112d7565b60405180910390f35b61008d610088366004610ffa565b610193565b005b61008d61009d366004610f35565b6104d2565b6100646100b0366004610f14565b61088c565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b838110156101155781810151838201526020016100fd565b50505050905090810190601f1680156101425780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561015f57600080fd5b505afa158015610173573d6000803e3d6000fd5b505050506040513d602081101561018957600080fd5b505190505b919050565b8661019d856108db565b60005a905060006101ad886108db565b90506101b98b826108f4565b156101c45750610410565b60006101ff6040518060400160405280601881526020017727ab26afa9ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760411b8152506100b5565b905060006102416040518060400160405280601d81526020017f4f564d5f43616e6f6e6963616c5472616e73616374696f6e436861696e0000008152506100b5565b9050816001600160a01b0316634d69ee578e8e8e6040518463ffffffff1660e01b815260040161027393929190611330565b60206040518083038186803b15801561028b57600080fd5b505afa15801561029f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102c39190610ee0565b6102e85760405162461bcd60e51b81526004016102df906115b8565b60405180910390fd5b6040516326f2b4e760e11b81526001600160a01b03821690634de569ce9061031a908d908d908d908d90600401611612565b60206040518083038186803b15801561033257600080fd5b505afa158015610346573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061036a9190610ee0565b6103865760405162461bcd60e51b81526004016102df9061146a565b86600001518860600151018b600001518d6060015101600101146103bc5760405162461bcd60e51b81526004016102df906114f6565b6103cb8d848d60000151610913565b7f41a48bde2468fac6f670f39b66d7b91f311053e1f28eab9d75056546e6eaac958d8c6000015185336040516104049493929190611365565b60405180910390a15050505b60005a820390506104476040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b8152506100b5565b6001600160a01b0316631e16e92f858533856040518563ffffffff1660e01b815260040180858152602001848152602001836001600160a01b03168152602001828152602001945050505050600060405180830381600087803b1580156104ad57600080fd5b505af11580156104c1573d6000803e3d6000fd5b505050505050505050505050505050565b868460005a905060006104e58b8961088c565b905060006105226040518060400160405280601881526020017727ab26afa9ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760411b8152506100b5565b905060006105566040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b8152506100b5565b9050826001600160a01b031663b2fa1c9e6040518163ffffffff1660e01b815260040160206040518083038186803b15801561059157600080fd5b505afa1580156105a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105c99190610ee0565b15156001146105ea5760405162461bcd60e51b81526004016102df90611389565b8a600001518c60600151016001018760000151896060015101146106205760405162461bcd60e51b81526004016102df906113f0565b816001600160a01b0316634d69ee578e8e8e6040518463ffffffff1660e01b815260040161065093929190611330565b60206040518083038186803b15801561066857600080fd5b505afa15801561067c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106a09190610ee0565b6106bc5760405162461bcd60e51b81526004016102df906115b8565b604051634d69ee5760e01b81526001600160a01b03831690634d69ee57906106ec908c908c908c90600401611330565b60206040518083038186803b15801561070457600080fd5b505afa158015610718573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061073c9190610ee0565b6107585760405162461bcd60e51b81526004016102df906114ae565b826001600160a01b031663c1c618b86040518163ffffffff1660e01b815260040160206040518083038186803b15801561079157600080fd5b505afa1580156107a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c99190610efc565b8914156107e85760405162461bcd60e51b81526004016102df90611568565b6107f2888e610a3e565b6000600160008f8d60405160200161080b92919061125a565b60405160208183030381529060405280519060200120815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b031602179055507f1e5fff3c23daf51ea67aaa3bbc738bcedaa98be5a5503f0e63a336a004b075b18d8c600001518c336040516104049493929190611365565b60006001600084846040516020016108a592919061125a565b60408051808303601f19018152918152815160209283012083529082019290925201600020546001600160a01b03169392505050565b60006108e682610b98565b805190602001209050919050565b600080610901848461088c565b6001600160a01b031614159392505050565b6109516040518060400160405280601c81526020017f4f564d5f53746174655472616e736974696f6e6572466163746f7279000000008152506100b5565b600054604051631168a38160e11b81526001600160a01b03928316926322d1470292610988929116908590889088906004016112eb565b602060405180830381600087803b1580156109a257600080fd5b505af11580156109b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109da91906110b6565b6001600085856040516020016109f192919061125a565b60405160208183030381529060405280519060200120815260200190815260200160002060006101000a8154816001600160a01b0302191690836001600160a01b03160217905550505050565b6000610a796040518060400160405280601881526020017727ab26afa9ba30ba32a1b7b6b6b4ba36b2b73a21b430b4b760411b8152506100b5565b90506000610aad6040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b8152506100b5565b604051632e38626b60e21b81529091506001600160a01b0383169063b8e189ac90610adc9087906004016115ff565b600060405180830381600087803b158015610af657600080fd5b505af1158015610b0a573d6000803e3d6000fd5b505050506000808560800151806020019051810190610b299190611120565b60405163abfbbe1360e01b815291935091506001600160a01b0384169063abfbbe1390610b5e90889085908790600401611311565b600060405180830381600087803b158015610b7857600080fd5b505af1158015610b8c573d6000803e3d6000fd5b50505050505050505050565b6060816000015182602001518360400151846060015185608001518660a001518760c00151604051602001610bd39796959493929190611268565b6040516020818303038152906040529050919050565b600067ffffffffffffffff831115610bfd57fe5b610c10601f8401601f19166020016116d1565b9050828152838383011115610c2457600080fd5b828260208301376000602084830101529392505050565b803561018e81611725565b600082601f830112610c56578081fd5b610c6583833560208501610be9565b9392505050565b80356002811061018e57600080fd5b600060a08284031215610c8c578081fd5b60405160a0810167ffffffffffffffff8282108183111715610caa57fe5b81604052829350843583526020850135602084015260408501356040840152606085013560608401526080850135915080821115610ce757600080fd5b50610cf485828601610c46565b6080830152505092915050565b600060408284031215610d12578081fd5b6040516040810167ffffffffffffffff8282108183111715610d3057fe5b8160405282935084358352602091508185013581811115610d5057600080fd5b8501601f81018713610d6157600080fd5b803582811115610d6d57fe5b8381029250610d7d8484016116d1565b8181528481019083860185850187018b1015610d9857600080fd5b600095505b83861015610dbb578035835260019590950194918601918601610d9d565b5080868801525050505050505092915050565b600060a08284031215610ddf578081fd5b60405160a0810167ffffffffffffffff8282108183111715610dfd57fe5b8160405282935084359150610e118261173d565b8183526020850135602084015260408501356040840152606085013560608401526080850135915080821115610ce757600080fd5b600060e08284031215610e57578081fd5b610e6160e06116d1565b90508135815260208201356020820152610e7d60408301610c6c565b6040820152610e8e60608301610c3b565b6060820152610e9f60808301610c3b565b608082015260a082013560a082015260c082013567ffffffffffffffff811115610ec857600080fd5b610ed484828501610c46565b60c08301525092915050565b600060208284031215610ef1578081fd5b8151610c658161173d565b600060208284031215610f0d578081fd5b5051919050565b60008060408385031215610f26578081fd5b50508035926020909101359150565b600080600080600080600060e0888a031215610f4f578283fd5b87359650602088013567ffffffffffffffff80821115610f6d578485fd5b610f798b838c01610c7b565b975060408a0135915080821115610f8e578485fd5b610f9a8b838c01610d01565b965060608a0135955060808a0135945060a08a0135915080821115610fbd578384fd5b610fc98b838c01610c7b565b935060c08a0135915080821115610fde578283fd5b50610feb8a828b01610d01565b91505092959891949750929550565b600080600080600080600060e0888a031215611014578081fd5b87359650602088013567ffffffffffffffff80821115611032578283fd5b61103e8b838c01610c7b565b975060408a0135915080821115611053578283fd5b61105f8b838c01610d01565b965060608a0135915080821115611074578283fd5b6110808b838c01610e46565b955060808a0135915080821115611095578283fd5b6110a18b838c01610dce565b945060a08a0135915080821115610fbd578283fd5b6000602082840312156110c7578081fd5b8151610c6581611725565b6000602082840312156110e3578081fd5b813567ffffffffffffffff8111156110f9578182fd5b8201601f81018413611109578182fd5b61111884823560208401610be9565b949350505050565b60008060408385031215611132578182fd5b82519150602083015161114481611725565b809150509250929050565b6001600160a01b03169052565b600081518084526111748160208601602086016116f5565b601f01601f19169290920160200192915050565b600081518352602082015160208401526040820151604084015260608201516060840152608082015160a0608085015261111860a085018261115c565b6000604083018251845260208084015160408287015282815180855260608801915083830194508592505b8083101561121057845182529383019360019290920191908301906111f0565b509695505050505050565b6000815115158352602082015160208401526040820151604084015260608201516060840152608082015160a0608085015261111860a085018261115c565b918252602082015260400190565b60008882528760208301526002871061127d57fe5b8660f81b60408301526bffffffffffffffffffffffff19808760601b166041840152808660601b1660558401525083606983015282516112c48160898501602087016116f5565b9190910160890198975050505050505050565b6001600160a01b0391909116815260200190565b6001600160a01b0394909416845260208401929092526040830152606082015260800190565b9283526001600160a01b03919091166020830152604082015260600190565b6000848252606060208301526113496060830185611188565b828103604084015261135b81856111c5565b9695505050505050565b938452602084019290925260408301526001600160a01b0316606082015260800190565b60208082526041908201527f5374617465207472616e736974696f6e2070726f63657373206d75737420626560408201527f20636f6d706c65746564207072696f7220746f2066696e616c697a6174696f6e6060820152601760f91b608082015260a00190565b60208082526054908201527f506f73742d737461746520726f6f7420676c6f62616c20696e646578206d757360408201527f7420657175616c20746f207468652070726520737461746520726f6f7420676c60608201527337b130b61034b73232bc1038363ab99037b7329760611b608082015260a00190565b60208082526024908201527f496e76616c6964207472616e73616374696f6e20696e636c7573696f6e20707260408201526337b7b31760e11b606082015260800190565b60208082526028908201527f496e76616c696420706f73742d737461746520726f6f7420696e636c7573696f6040820152673710383937b7b31760c11b606082015260800190565b6020808252604c908201527f5072652d737461746520726f6f7420676c6f62616c20696e646578206d75737460408201527f20657175616c20746f20746865207472616e73616374696f6e20726f6f74206760608201526b3637b130b61034b73232bc1760a11b608082015260a00190565b60208082526030908201527f5374617465207472616e736974696f6e20686173206e6f74206265656e20707260408201526f37bb32b710333930bab23ab632b73a1760811b606082015260800190565b60208082526027908201527f496e76616c6964207072652d737461746520726f6f7420696e636c7573696f6e60408201526610383937b7b31760c91b606082015260800190565b600060208252610c656020830184611188565b60006080825285516080830152602086015160a083015260408601516002811061163857fe5b60c083015260608601516001600160a01b031660e0830152608086015161166361010084018261114f565b5060a086015161012083015260c086015160e061014084015261168a61016084018261115c565b9050828103602084015261169e818761121b565b905082810360408401526116b28186611188565b905082810360608401526116c681856111c5565b979650505050505050565b60405181810167ffffffffffffffff811182821017156116ed57fe5b604052919050565b60005b838110156117105781810151838201526020016116f8565b8381111561171f576000848401525b50505050565b6001600160a01b038116811461173a57600080fd5b50565b801515811461173a57600080fdfea2646970667358221220ab02b9a67a211940c347821f42d6dbba1dfaf13e125f2924fb49f5ab8a0ff88c64736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_libAddressManager": "Address of the Address Manager."
        }
      },
      "finalizeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes32,bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))": {
        "params": {
          "_postStateRoot": "State root after the fraudulent transaction.",
          "_postStateRootBatchHeader": "Batch header for the provided post-state root.",
          "_postStateRootProof": "Inclusion proof for the provided post-state root.",
          "_preStateRoot": "State root before the fraudulent transaction.",
          "_preStateRootBatchHeader": "Batch header for the provided pre-state root.",
          "_preStateRootProof": "Inclusion proof for the provided pre-state root.",
          "_txHash": "The transaction for the state root"
        }
      },
      "getStateTransitioner(bytes32,bytes32)": {
        "params": {
          "_preStateRoot": "State root to query a transitioner for."
        },
        "returns": {
          "_transitioner": "Corresponding state transitioner contract."
        }
      },
      "initializeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),(uint256,uint256,uint8,address,address,uint256,bytes),(bool,uint256,uint256,uint256,bytes),(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))": {
        "params": {
          "_preStateRoot": "State root before the fraudulent transaction.",
          "_preStateRootBatchHeader": "Batch header for the provided pre-state root.",
          "_preStateRootProof": "Inclusion proof for the provided pre-state root.",
          "_transaction": "OVM transaction claimed to be fraudulent.",
          "_transactionBatchHeader": "Batch header for the provided transaction.",
          "_transactionProof": "Inclusion proof for the provided transaction.",
          "_txChainElement": "OVM transaction chain element."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "finalizeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),bytes32,bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))": {
        "notice": "Finalizes the fraud verification process."
      },
      "getStateTransitioner(bytes32,bytes32)": {
        "notice": "Retrieves the state transitioner for a given root."
      },
      "initializeFraudVerification(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]),(uint256,uint256,uint8,address,address,uint256,bytes),(bool,uint256,uint256,uint256,bytes),(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))": {
        "notice": "Begins the fraud verification process."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11707,
        "contract": "contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol:OVM_FraudVerifier",
        "label": "libAddressManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Lib_AddressManager)11700"
      },
      {
        "astId": 8516,
        "contract": "contracts/optimistic-ethereum/OVM/verification/OVM_FraudVerifier.sol:OVM_FraudVerifier",
        "label": "transitioners",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes32,t_contract(iOVM_StateTransitioner)10951)"
      }
    ],
    "types": {
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(Lib_AddressManager)11700": {
        "encoding": "inplace",
        "label": "contract Lib_AddressManager",
        "numberOfBytes": "20"
      },
      "t_contract(iOVM_StateTransitioner)10951": {
        "encoding": "inplace",
        "label": "contract iOVM_StateTransitioner",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_contract(iOVM_StateTransitioner)10951)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => contract iOVM_StateTransitioner)",
        "numberOfBytes": "32",
        "value": "t_contract(iOVM_StateTransitioner)10951"
      }
    }
  }
}